/**
 * Export-Ready Test Generator
 * 
 * Generates test scripts that are ready for export to complete environment.
 * These scripts include BPMN metadata, clear TODO markers, and structure
 * that can be easily completed in the target environment.
 * 
 * See docs/STARTER_VS_COMPLETE_ENVIRONMENT.md for context
 */

import type { BpmnElement } from '@/lib/bpmnParser';
import type { EpicScenario } from './epicDocTypes';
import { inferImplementationMapping } from './implementationMappingInference';
import { ensureTestContext, getDefaultContextForBpmnScenario } from './testContextGuard';

export interface ExportReadyTestOptions {
  includeBpmnMetadata?: boolean;
  includePlaceholders?: boolean;
  exportFormat?: 'playwright' | 'jest' | 'mocha';
}

/**
 * Generate export-ready test script
 * These can be taken to complete environment for finalization
 */
export function generateExportReadyTest(
  element: BpmnElement,
  scenario: EpicScenario,
  options: ExportReadyTestOptions = {}
): string {
  const {
    includeBpmnMetadata = true,
    includePlaceholders = true,
    exportFormat = 'playwright',
  } = options;

  // BPMN scenarios are always for fictional app
  const context = getDefaultContextForBpmnScenario();

  // Validate context
  ensureTestContext(
    context,
    {
      appContext: context,
      description: `Export-ready test for ${scenario.name}`,
      contextConfirmed: true,
    },
    {
      testName: scenario.name,
      persona: scenario.persona,
      bpmnFile: element.bpmnFile || 'unknown',
    }
  );

  // Infer basic mapping (for structure, not final routes)
  const inferredMapping = inferImplementationMapping(element, context);

  // Generate test with clear export markers
  return generateTestWithExportMarkers(
    element,
    scenario,
    inferredMapping,
    { includeBpmnMetadata, includePlaceholders, exportFormat }
  );
}

function generateTestWithExportMarkers(
  element: BpmnElement,
  scenario: EpicScenario,
  mapping: ReturnType<typeof inferImplementationMapping>,
  options: {
    includeBpmnMetadata: boolean;
    includePlaceholders: boolean;
    exportFormat: string;
  }
): string {
  const testName = scenario.name.replace(/'/g, "\\'");
  const nodeType = element.type.replace('bpmn:', '');
  const nodeName = element.name || element.id;

  let code = '';

  // BPMN metadata as comments
  if (options.includeBpmnMetadata) {
    code += generateBpmnMetadataHeader(element, scenario);
  }

  // Import statements
  code += `import { test, expect } from '@playwright/test';\n`;
  if (options.includePlaceholders) {
    code += `// ⚠️ TODO (Complete Environment): Import test data fixtures\n`;
    code += `// import { testData } from '../fixtures/mortgage-test-data';\n\n`;
  }

  // Test structure
  const riskLevelLabel = scenario.riskLevel ? `${scenario.riskLevel} - ` : '';
  const describeName = `${nodeName} - ${scenario.type} Path`;

  code += `test.describe('${riskLevelLabel}${describeName}', () => {\n`;
  code += `  test('${testName}', async ({ page${nodeType === 'ServiceTask' ? ', request' : ''} }) => {\n`;

  // Persona setup
  if (scenario.persona && scenario.persona !== 'system' && scenario.persona !== 'unknown') {
    code += generatePersonaSetupForExport(scenario.persona, options.includePlaceholders);
  }

  // Test body
  if (scenario.uiFlow && scenario.uiFlow.length > 0) {
    code += generateUiFlowStructure(scenario.uiFlow, mapping, options.includePlaceholders);
  } else {
    code += generatePlaceholderTestBody(element, scenario, mapping, options.includePlaceholders);
  }

  // Assertions
  code += generateAssertionsForExport(scenario, options.includePlaceholders);

  // Add warnings if any
  if (mapping.warnings.length > 0) {
    code += `\n    // Warnings from inference:\n`;
    mapping.warnings.forEach((warning) => {
      code += `    // ${warning}\n`;
    });
  }

  code += `  });\n`;
  code += `});\n`;

  return code;
}

function generateBpmnMetadataHeader(
  element: BpmnElement,
  scenario: EpicScenario
): string {
  let header = `// ============================================\n`;
  header += `// EXPORT-READY TEST - Generated by BPMN Planner\n`;
  header += `// BPMN File: ${element.bpmnFile || 'unknown'}\n`;
  header += `// Node ID: ${element.id}\n`;
  header += `// Node Type: ${element.type.replace('bpmn:', '')}\n`;
  header += `// Node Name: ${element.name || element.id}\n`;
  header += `// Scenario ID: ${scenario.id}\n`;
  header += `// Scenario Name: ${scenario.name}\n`;
  header += `// Scenario Type: ${scenario.type}\n`;
  if (scenario.persona) header += `// Persona: ${scenario.persona}\n`;
  if (scenario.riskLevel) header += `// Risk Level: ${scenario.riskLevel}\n`;
  if (scenario.assertionType) header += `// Assertion Type: ${scenario.assertionType}\n`;
  header += `// ============================================\n`;
  header += `// This test is ready for export to complete environment.\n`;
  header += `// Complete environment should:\n`;
  header += `// 1. Add actual routes/endpoints\n`;
  header += `// 2. Add actual UI locators\n`;
  header += `// 3. Add test data fixtures\n`;
  header += `// 4. Validate and run tests\n`;
  header += `// ============================================\n\n`;
  return header;
}

function generatePersonaSetupForExport(persona: string, includePlaceholders: boolean): string {
  let code = `\n    // Setup: Login as ${persona}\n`;
  if (includePlaceholders) {
    code += `    // ⚠️ TODO (Complete Environment): Update login route and selectors\n`;
  }
  code += `    await page.goto('/login'); // ⚠️ TODO: Update with actual login route\n`;
  code += `    await page.fill('#email', '${persona}@example.com'); // ⚠️ TODO: Use real test credentials\n`;
  code += `    await page.fill('#password', 'password123'); // ⚠️ TODO: Use real test password\n`;
  code += `    await page.click('#login-btn'); // ⚠️ TODO: Verify login button selector\n`;
  return code;
}

function generateUiFlowStructure(
  uiFlow: Array<{ pageId: string; action: string; locatorId?: string; dataProfileId?: string }>,
  mapping: ReturnType<typeof inferImplementationMapping>,
  includePlaceholders: boolean
): string {
  let code = `\n    // Navigation steps (from uiFlow)\n`;
  if (includePlaceholders) {
    code += `    // ⚠️ TODO (Complete Environment): Update routes and locators\n`;
  }

  uiFlow.forEach((step, index) => {
    const route = mapping?.ui?.route || `/${step.pageId}`;

    if (index === 0 || uiFlow[index - 1].pageId !== step.pageId) {
      code += `\n    // Step ${index + 1}: Navigate to ${step.pageId}\n`;
      code += `    await page.goto('${route}'); // ⚠️ TODO: Update with actual route\n`;
    }

    code += `    // ${step.action}\n`;
    if (step.locatorId) {
      const actionLower = step.action.toLowerCase();
      if (actionLower.includes('fill') || actionLower.includes('enter') || actionLower.includes('input')) {
        code += `    await page.fill('#${step.locatorId}', 'TODO: Add test data'); // ⚠️ TODO: Update locator and add test data\n`;
        if (step.dataProfileId) {
          code += `    // Data profile: ${step.dataProfileId} - ⚠️ TODO: Use testData.${step.dataProfileId}\n`;
        }
      } else if (actionLower.includes('click')) {
        code += `    await page.click('#${step.locatorId}'); // ⚠️ TODO: Verify locator\n`;
      } else if (actionLower.includes('select')) {
        code += `    await page.selectOption('#${step.locatorId}', 'TODO: Add option'); // ⚠️ TODO: Update locator and add option\n`;
      } else if (actionLower.includes('check') || actionLower.includes('verify')) {
        code += `    await expect(page.locator('#${step.locatorId}')).toBeVisible(); // ⚠️ TODO: Verify locator and assertion\n`;
      } else {
        code += `    await page.locator('#${step.locatorId}').click(); // ⚠️ TODO: Verify action and locator\n`;
      }
    } else {
      code += `    // ⚠️ TODO: Implement action "${step.action}" (locatorId missing)\n`;
    }
  });

  return code;
}

function generatePlaceholderTestBody(
  element: BpmnElement,
  scenario: EpicScenario,
  mapping: ReturnType<typeof inferImplementationMapping>,
  includePlaceholders: boolean
): string {
  let code = `\n    // Test body based on scenario: ${scenario.description}\n`;
  if (includePlaceholders) {
    code += `    // ⚠️ TODO (Complete Environment): Add navigation steps\n`;
    if (mapping?.ui?.route) {
      code += `    // Suggested route (inferred): ${mapping.ui.route}\n`;
    }
  }

  if (mapping?.ui?.route) {
    code += `    await page.goto('${mapping.ui.route}'); // ⚠️ TODO: Update with actual route\n`;
  } else {
    code += `    await page.goto('/'); // ⚠️ TODO: Add actual route in complete environment\n`;
  }

  code += `    // ⚠️ TODO (Complete Environment): Add test steps based on scenario\n`;
  code += `    // Scenario description: ${scenario.description}\n`;

  return code;
}

function generateAssertionsForExport(scenario: EpicScenario, includePlaceholders: boolean): string {
  let code = `\n    // Assertions based on scenario outcome\n`;
  code += `    // Expected outcome: ${scenario.outcome}\n`;

  const outcome = scenario.outcome.toLowerCase();
  if (outcome.includes('success') || outcome.includes('slutför') || outcome.includes('lyckas')) {
    code += `    await expect(page.locator('.success-message, .confirmation')).toBeVisible();\n`;
    if (includePlaceholders) {
      code += `    // ⚠️ TODO (Complete Environment): Verify actual success message locator\n`;
    }
  } else if (outcome.includes('error') || outcome.includes('fel') || outcome.includes('misslyckas')) {
    code += `    await expect(page.locator('.error-message, .error')).toBeVisible();\n`;
    if (includePlaceholders) {
      code += `    // ⚠️ TODO (Complete Environment): Verify actual error message locator\n`;
    }
  } else {
    code += `    // ⚠️ TODO (Complete Environment): Add assertions based on scenario outcome\n`;
  }

  return code;
}

