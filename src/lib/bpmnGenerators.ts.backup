import { BpmnElement, BpmnSubprocess, parseBpmnFile } from '@/lib/bpmnParser';
import { CriterionCategory, CriterionType } from '@/hooks/useDorDodStatus';
import { generateTestCode } from '@/tests/meta/jiraBpmnMeta';
import { buildNodeDocumentationContext, type NodeDocumentationContext } from '@/lib/documentationContext';
import type { BpmnProcessNode } from '@/lib/bpmnProcessGraph';
import {
  renderFeatureGoalDoc,
  renderEpicDoc,
  renderBusinessRuleDoc,
  type TemplateLinks,
} from '@/lib/documentationTemplates';
import { wrapLlmContentAsDocument } from '@/lib/wrapLlmContent';
import { getNodeDocFileKey, getNodeTestFileKey, getFeatureGoalDocFileKey } from '@/lib/nodeArtifactPaths';
import { generateDocumentationWithLlm, type DocumentationDocType, type ChildNodeDocumentation } from '@/lib/llmDocumentation';
import { generateTestSpecWithLlm } from '@/lib/llmTests';
import type { LlmProvider } from './llmClientAbstraction';
import { getLlmClient, getDefaultLlmProvider } from './llmClients';
import { supabase } from '@/integrations/supabase/client';
import { storageFileExists } from '@/lib/artifactUrls';
import { buildDocStoragePaths } from '@/lib/artifactPaths';
import { isLlmEnabled } from '@/lib/llmClient';
import { logLlmFallback } from '@/lib/llmMonitoring';
import { saveLlmDebugArtifact } from '@/lib/llmDebugStorage';
import { CloudLlmAccountInactiveError } from '@/lib/llmClients/cloudLlmClient';
import {
  buildProcessHierarchy,
  type NormalizedProcessDefinition,
} from '@/lib/bpmn/buildProcessHierarchy';
import {
  buildProcessDefinitionsFromRegistry,
  type ProcessRegistryEntry,
} from '@/lib/bpmn/processDefinition';
import {
  resolveProcessFileName,
  resolveProcessFileNameByInternalId,
  traverseHierarchy,
} from '@/lib/bpmn/hierarchyTraversal';
import type { HierarchyNode, SubprocessLink } from '@/lib/bpmn/types';
import {
  buildBpmnProcessGraph,
  createGraphSummary,
  getTestableNodes,
} from '@/lib/bpmnProcessGraph';
import {
  buildFlowGraph,
  findStartEvents,
  findPathsThroughProcess,
  type ProcessPath,
  type FlowGraph,
} from '@/lib/bpmnFlowExtractor';
import { testMapping, type TestScenario } from '@/data/testMapping';
import {
  createPlannedScenariosFromGraph,
  savePlannedScenarios,
  type PlannedScenarioRow,
} from '@/lib/plannedScenariosHelper';
import type { ProcessTreeNode } from '@/lib/processTree';
import { buildProcessTreeFromGraph } from '@/lib/bpmn/buildProcessTreeFromGraph';
import { generateExportReadyTest } from './exportReadyTestGenerator';
import type { EpicUserStory } from './epicDocTypes';

export type GenerationPhaseKey =
  | 'graph:start'
  | 'graph:complete'
  | 'hier-tests:start'
  | 'hier-tests:file'
  | 'hier-tests:complete'
  | 'node-analysis:start'
  | 'node-analysis:node'
  | 'node-analysis:complete'
  | 'docgen:start'
  | 'docgen:file'
  | 'docgen:complete'
  | 'total:init';
import { getBpmnFileUrl } from '@/hooks/useDynamicBpmnFiles';
import { buildDorDodCriteria, type DorDodNodeType } from '@/lib/templates/dorDodTemplates';

// ============= HIERARCHICAL TEST GENERATION =============

/**
 * Node for hierarchical test structure
 */
export interface HierarchicalTestNode {
  name: string;
  type: string;
  id: string;
  parentPath?: string[];
  children?: HierarchicalTestNode[];
}


/**
 * Legacy function for backward compatibility
 * Recursively generate test structure for a node and its children
 */
function generateNodeTests(node: HierarchicalTestNode, indentLevel: number): string {
  const indent = '  '.repeat(indentLevel);
  let result = '';

  if (node.children && Array.isArray(node.children) && node.children.length > 0) {
    // This is a container (CallActivity/Feature Goal)
    result += `\n${indent}test.describe('${node.name}', () => {\n`;
    node.children.forEach(child => {
      result += generateNodeTests(child, indentLevel + 1);
    });
    result += `${indent}});\n`;
  } else {
    // This is a leaf node (task/epic) - actual test
    const contextPath = node.parentPath && node.parentPath.length > 0
      ? node.parentPath.join(' ‚Üí ') + ' ‚Üí ' + node.name
      : node.name;
      
    result += `\n${indent}test('${node.name}', async ({ page }) => {\n`;
    result += `${indent}  // TODO: Implement test for ${node.name}\n`;
    result += `${indent}  // Type: ${node.type}\n`;
    result += `${indent}  // ID: ${node.id}\n`;
    result += `${indent}  // Context: ${contextPath}\n`;
    
    // Add type-specific scaffolding
    if (node.type === 'UserTask') {
      result += `${indent}  // Example: Test form display and submission\n`;
      result += `${indent}  // await page.goto('/path-to-task');\n`;
      result += `${indent}  // await expect(page.locator('[data-testid="${node.id}-form"]')).toBeVisible();\n`;
    } else if (node.type === 'ServiceTask') {
      result += `${indent}  // Example: Mock service call and verify\n`;
      result += `${indent}  // await page.route('**/api/service', route => route.fulfill({ ... }));\n`;
    } else if (node.type === 'BusinessRuleTask') {
      result += `${indent}  // Example: Test business rule evaluation\n`;
      result += `${indent}  // Provide input data and verify decision output\n`;
    } else if (node.type === 'CallActivity') {
      result += `${indent}  // Example: Test subprocess invocation\n`;
      result += `${indent}  // Verify subprocess is called and completes successfully\n`;
    }
    
    result += `${indent}  expect(true).toBe(true); // Replace with actual assertions\n`;
    result += `${indent}});\n`;
  }

  return result;
}

// ============= EXPORT-READY TEST GENERATOR =============

/**
 * Generate export-ready test from EpicUserStory
 * This creates tests ready for export to complete environment
 */
export function generateExportReadyTestFromUserStory(
  element: BpmnElement,
  userStory: EpicUserStory
): string {
  // Convert user story to a scenario-like format for the export generator
  const scenarioLike = {
    id: userStory.id,
    name: `User Story: ${userStory.goal}`,
    type: 'Happy', // Default, can be determined from acceptance criteria
    description: `Som ${userStory.role} vill jag ${userStory.goal} s√• att ${userStory.value}`,
    outcome: userStory.acceptanceCriteria.join('; '),
  };
  return generateExportReadyTest(element, scenarioLike, {
    includeBpmnMetadata: true,
    includePlaceholders: true,
    exportFormat: 'playwright',
  });
}

// ============= LEGACY TEST SKELETON GENERATOR (for backward compatibility) =============

export function generateTestSkeleton(element: BpmnElement, llmScenarios?: { name: string; description: string; expectedResult?: string; steps?: string[] }[]): string {
  const testName = element.name || element.id;
  const nodeType = element.type.replace('bpmn:', '');

  let testTemplate = `import { test, expect } from '@playwright/test';

test.describe('${testName} Tests', () => {
  test('should load the page successfully', async ({ page }) => {
    await page.goto('/');
    await expect(page).toHaveTitle(/BPMN Viewer/);
  });
`;

  if (llmScenarios && llmScenarios.length) {
    llmScenarios.forEach((scenario, index) => {
      const stepsComment = scenario.steps?.length
        ? scenario.steps.map((step, idx) => `    // ${idx + 1}. ${step}`).join('\n')
        : '    // Beskriv stegen h√§r';

      testTemplate += `
  test('${scenario.name.replace(/'/g, "\\'")}', async ({ page }) => {
    await page.goto('/');
${stepsComment}
    // F√∂rv√§ntat resultat: ${scenario.expectedResult || 'Beskriv resultat'}
    expect(true).toBe(true);
  });
`;
    });

    testTemplate += `});
`;
    return testTemplate;
  }

  // Add specific tests based on node type
  if (nodeType === 'UserTask') {
    testTemplate += `
  test('should display ${testName} form', async ({ page }) => {
    await page.goto('/');
    
    // TODO: Add selectors for form elements
    // Example: await expect(page.locator('[data-testid="${element.id}-form"]')).toBeVisible();
  });

  test('should validate ${testName} input', async ({ page }) => {
    await page.goto('/');
    
    // TODO: Test input validation
    const testData = {
      // Add test data fields
    };
    
    expect(testData).toBeTruthy();
  });

  test('should submit ${testName} successfully', async ({ page }) => {
    await page.goto('/');
    
    // TODO: Test successful submission
  });
`;
  } else if (nodeType === 'ServiceTask') {
    testTemplate += `
  test('should call ${testName} service', async ({ page }) => {
    await page.goto('/');
    
    // TODO: Mock service call
    const serviceResponse = {
      status: 'success',
      data: {}
    };
    
    expect(serviceResponse.status).toBe('success');
  });

  test('should handle ${testName} service errors', async ({ page }) => {
    await page.goto('/');
    
    // TODO: Test error handling
  });
`;
  } else if (nodeType === 'BusinessRuleTask') {
    testTemplate += `
  test('should evaluate ${testName} rules', async ({ page }) => {
    await page.goto('/');
    
    // TODO: Test business rule evaluation
    const ruleInput = {
      // Add rule input data
    };
    
    expect(ruleInput).toBeTruthy();
  });

  test('should handle ${testName} rule outcomes', async ({ page }) => {
    await page.goto('/');
    
    // TODO: Test different rule outcomes
  });
`;
  } else if (nodeType === 'CallActivity') {
    testTemplate += `
  test('should execute ${testName} subprocess', async ({ page }) => {
    await page.goto('/');
    
    // TODO: Test subprocess execution
  });

  test('should handle ${testName} subprocess completion', async ({ page }) => {
    await page.goto('/');
    
    // TODO: Test subprocess completion handling
  });
`;
  }

  testTemplate += `});
`;

  return testTemplate;
}

// ============= DOR/DOD GENERATOR =============

interface DorDodCriterion {
  criterion_type: CriterionType;
  criterion_category: CriterionCategory;
  criterion_key: string;
  criterion_text: string;
}

export interface GeneratedCriterion {
  criterion_type: CriterionType;
  criterion_category: CriterionCategory;
  criterion_key: string;
  criterion_text: string;
  node_type?: string; // BPMN node type (UserTask, ServiceTask, etc.)
  bpmn_element_id?: string; // BPMN element ID
  bpmn_file?: string; // BPMN file name
}

export function generateDorDodCriteria(subprocessName: string, nodeType: string): DorDodCriterion[] {
  const criteria: DorDodCriterion[] = [];
  const normalizedName = subprocessName.toLowerCase().replace(/\s+/g, '_');

  // Definition of Ready (DoR) criteria
  criteria.push(
    {
      criterion_type: 'dor',
      criterion_category: 'process_krav',
      criterion_key: `${normalizedName}_process_defined`,
      criterion_text: 'Processfl√∂de √§r definierat och dokumenterat'
    },
    {
      criterion_type: 'dor',
      criterion_category: 'data_input_output',
      criterion_key: `${normalizedName}_data_inputs`,
      criterion_text: 'Input-data och k√§llor √§r identifierade'
    },
    {
      criterion_type: 'dor',
      criterion_category: 'data_input_output',
      criterion_key: `${normalizedName}_data_outputs`,
      criterion_text: 'Output-data och destinationer √§r definierade'
    }
  );

  // Add type-specific DoR criteria
  if (nodeType === 'UserTask') {
    criteria.push(
      {
        criterion_type: 'dor',
        criterion_category: 'design',
        criterion_key: `${normalizedName}_ui_design`,
        criterion_text: 'UI-design √§r godk√§nd i Figma'
      },
      {
        criterion_type: 'dor',
        criterion_category: 'funktion_krav',
        criterion_key: `${normalizedName}_user_stories`,
        criterion_text: 'User stories √§r definierade och accepterade'
      }
    );
  }

  if (nodeType === 'ServiceTask' || nodeType === 'BusinessRuleTask') {
    criteria.push(
      {
        criterion_type: 'dor',
        criterion_category: 'data_api',
        criterion_key: `${normalizedName}_api_spec`,
        criterion_text: 'API-specifikation √§r dokumenterad'
      },
      {
        criterion_type: 'dor',
        criterion_category: 'teknik_arkitektur',
        criterion_key: `${normalizedName}_tech_design`,
        criterion_text: 'Teknisk design √§r granskad'
      }
    );
  }

  criteria.push(
    {
      criterion_type: 'dor',
      criterion_category: 'test_kvalitet',
      criterion_key: `${normalizedName}_test_cases`,
      criterion_text: 'Testfall √§r definierade'
    },
    {
      criterion_type: 'dor',
      criterion_category: 'planering_beroenden',
      criterion_key: `${normalizedName}_dependencies`,
      criterion_text: 'Beroenden och integrationer √§r identifierade'
    },
    {
      criterion_type: 'dor',
      criterion_category: 'team_alignment',
      criterion_key: `${normalizedName}_team_aligned`,
      criterion_text: 'Team har diskuterat och f√∂rst√•r uppgiften'
    }
  );

  // Definition of Done (DoD) criteria
  criteria.push(
    {
      criterion_type: 'dod',
      criterion_category: 'funktion_krav',
      criterion_key: `${normalizedName}_requirements_met`,
      criterion_text: 'Alla funktionella krav √§r implementerade'
    },
    {
      criterion_type: 'dod',
      criterion_category: 'test_kvalitet',
      criterion_key: `${normalizedName}_tests_passed`,
      criterion_text: 'Alla tester √§r gr√∂na (unit, integration, E2E)'
    },
    {
      criterion_type: 'dod',
      criterion_category: 'test_kvalitet',
      criterion_key: `${normalizedName}_test_coverage`,
      criterion_text: 'Testt√§ckning uppfyller krav (minst 80%)'
    },
    {
      criterion_type: 'dod',
      criterion_category: 'dokumentation',
      criterion_key: `${normalizedName}_documented`,
      criterion_text: 'Dokumentation √§r uppdaterad'
    },
    {
      criterion_type: 'dod',
      criterion_category: 'teknik_drift',
      criterion_key: `${normalizedName}_deployed`,
      criterion_text: 'Kod √§r deployad till testmilj√∂'
    },
    {
      criterion_type: 'dod',
      criterion_category: 'teknik_drift',
      criterion_key: `${normalizedName}_monitoring`,
      criterion_text: 'Monitoring och logging √§r implementerat'
    },
    {
      criterion_type: 'dod',
      criterion_category: 'overlamning',
      criterion_key: `${normalizedName}_code_review`,
      criterion_text: 'Code review √§r genomf√∂rd och godk√§nd'
    },
    {
      criterion_type: 'dod',
      criterion_category: 'overlamning',
      criterion_key: `${normalizedName}_demo`,
      criterion_text: 'Demo genomf√∂rd f√∂r stakeholders'
    }
  );

  return criteria;
}

/**
 * Genererar DoR/DoD-kriterier baserat p√• nodtyp.
 * St√∂djer: ServiceTask, UserTask, BusinessRuleTask, CallActivity
 */
export function generateDorDodForNodeType(
  nodeType: DorDodNodeType,
  normalizedName: string
): GeneratedCriterion[] {
  const criteria = buildDorDodCriteria(nodeType, normalizedName);
  // Convert DorDodCriterion[] to GeneratedCriterion[]
  // GeneratedCriterion extends DorDodCriterion with optional metadata
  return criteria.map(c => ({
    ...c,
    criterion_category: c.criterion_category as CriterionCategory,
  }));
}

// DoR/DoD criteria are sourced from static templates in src/lib/templates/dorDodTemplates.ts
// to ensure the LLM never rewrites or invents definitions.


// ============= DOCUMENTATION GENERATOR =============

export interface SubprocessSummary {
  fileName: string;
  totalNodes: number;
  userTasks: number;
  serviceTasks: number;
  businessRuleTasks: number;
  gateways: number;
  keyNodes: Array<{
    id: string;
    name: string;
    type: string;
  }>;
}

export function generateDocumentationHTML(
  element: BpmnElement, 
  subprocessFile?: string,
  subprocessSummary?: SubprocessSummary,
  dorDodCriteria: DorDodCriterion[] = [],
): string {
  const nodeType = element.type.replace('bpmn:', '');
  const documentation = element.businessObject.documentation?.[0]?.text || 'Ingen dokumentation tillg√§nglig.';

  const html = `<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${element.name || element.id} - ${nodeType}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            min-height: 100vh;
        }
        
        header {
            border-bottom: 3px solid #0066cc;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        
        h1 {
            color: #0066cc;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 1.2rem;
        }
        
        .meta {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 12px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .meta-label {
            font-weight: 600;
            color: #0066cc;
        }
        
        section {
            margin-bottom: 40px;
        }
        
        h2 {
            color: #0066cc;
            font-size: 1.8rem;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #0066cc;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .badge-primary {
            background: #0066cc;
            color: white;
        }
        
        .badge-warning {
            background: #ff9800;
            color: white;
        }
        
        pre {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
        }
        
        code {
            font-family: 'Courier New', monospace;
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>${element.name || element.id}</h1>
            <p class="subtitle">${nodeType}</p>
            <div class="meta">
                <div class="meta-item">
                    <span class="meta-label">Node ID:</span>
                    <code>${element.id}</code>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Type:</span>
                    <span class="badge badge-primary">${nodeType}</span>
                </div>
                ${subprocessFile ? `
                <div class="meta-item">
                    <span class="meta-label">Subprocess:</span>
                    <a href="${subprocessFile}.html">${subprocessFile}</a>
                </div>
                ` : ''}
            </div>
        </header>

        <section>
            <h2>üìã Beskrivning</h2>
            <div class="card">
                <p>${documentation}</p>
            </div>
        </section>

        ${nodeType === 'UserTask' ? `
        <section>
            <h2>üë§ User Task Information</h2>
            <div class="card">
                <p><strong>Anv√§ndare:</strong> Interaktiv uppgift som kr√§ver manuell input</p>
                <p><strong>Typ av interaktion:</strong> Formul√§r, godk√§nnande eller datainmatning</p>
            </div>
        </section>
        ` : ''}

        ${nodeType === 'ServiceTask' ? `
        <section>
            <h2>‚öôÔ∏è Service Task Information</h2>
            <div class="card">
                <p><strong>Typ:</strong> Automatisk systemuppgift</p>
                <p><strong>Utf√∂rs av:</strong> Backend-service eller API-anrop</p>
            </div>
        </section>
        ` : ''}

        ${nodeType === 'BusinessRuleTask' ? `
        <section>
            <h2>üìä Business Rule Task Information</h2>
            <div class="card">
                <p><strong>Typ:</strong> Regelbaserad beslutspunkt</p>
                <p><strong>Utf√∂rs av:</strong> Aff√§rsregelmotor eller beslutslogik</p>
                ${subprocessFile ? `
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                    <h3>üìã DMN Decision Table: ${subprocessFile}</h3>
                    ${subprocessSummary ? `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 15px 0;">
                        <div class="card" style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #0066cc;">${subprocessSummary.totalNodes}</div>
                            <div style="font-size: 0.9rem; color: #666;">Antal regler</div>
                        </div>
                        <div class="card" style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #10b981;">${subprocessSummary.userTasks}</div>
                            <div style="font-size: 0.9rem; color: #666;">Input-kolumner</div>
                        </div>
                        <div class="card" style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #3b82f6;">${subprocessSummary.serviceTasks}</div>
                            <div style="font-size: 0.9rem; color: #666;">Output-kolumner</div>
                        </div>
                    </div>
                    
                    ${subprocessSummary.keyNodes.length > 0 ? `
                    <div style="margin-top: 20px;">
                        <h4>üì• Input-kolumner:</h4>
                        <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 10px;">
                            ${subprocessSummary.keyNodes.slice(0, subprocessSummary.userTasks).map(node => `
                                <div class="card" style="display: flex; justify-content: between; align-items: center;">
                                    <strong>${node.name}</strong>
                                    <span style="font-size: 0.85rem; color: #666;">${node.type}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : ''}
                    
                    <div style="margin-top: 20px;">
                        <p style="color: #666; font-size: 0.9rem;">
                            üí° DMN-tabellen visas automatiskt i BPMN-viewern n√§r du v√§ljer denna nod
                        </p>
                    </div>
                    ` : `
                    <p><span class="badge badge-warning">‚ö†Ô∏è DMN-fil ej hittad</span></p>
                    <p style="font-size: 0.9rem; color: #666; margin-top: 10px;">
                        F√∂rv√§ntad fil: <code>${subprocessFile}</code>
                    </p>
                    `}
                </div>
                ` : ''}
            </div>
        </section>
        ` : ''}

        ${nodeType === 'CallActivity' ? `
        <section>
            <h2>üîÑ Call Activity Information</h2>
            <div class="card">
                <p><strong>Typ:</strong> Anropar subprocess</p>
                ${subprocessFile ? `<p><strong>Subprocess fil:</strong> <a href="${subprocessFile}.html">${subprocessFile}</a></p>` : '<p><span class="badge badge-warning">‚ö†Ô∏è Subprocess ej specificerad</span></p>'}
                
                ${subprocessSummary ? `
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                    <h3>üìä Subprocess-√∂versikt: ${subprocessSummary.fileName}</h3>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 15px 0;">
                        <div class="card" style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #0066cc;">${subprocessSummary.totalNodes}</div>
                            <div style="font-size: 0.9rem; color: #666;">Totalt antal noder</div>
                        </div>
                        <div class="card" style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #10b981;">${subprocessSummary.userTasks}</div>
                            <div style="font-size: 0.9rem; color: #666;">User Tasks</div>
                        </div>
                        <div class="card" style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #3b82f6;">${subprocessSummary.serviceTasks}</div>
                            <div style="font-size: 0.9rem; color: #666;">Service Tasks</div>
                        </div>
                        <div class="card" style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #f59e0b;">${subprocessSummary.businessRuleTasks}</div>
                            <div style="font-size: 0.9rem; color: #666;">Business Rules</div>
                        </div>
                        <div class="card" style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #8b5cf6;">${subprocessSummary.gateways}</div>
                            <div style="font-size: 0.9rem; color: #666;">Gateways</div>
                        </div>
                    </div>
                    
                    ${subprocessSummary.keyNodes.length > 0 ? `
                    <div style="margin-top: 20px;">
                        <h4>üîë Viktiga noder i subprocess:</h4>
                        <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px;">
                            ${subprocessSummary.keyNodes.map(node => `
                                <div class="card" style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <strong>${node.name || node.id}</strong>
                                        <div style="font-size: 0.85rem; color: #666; font-family: monospace;">${node.id}</div>
                                    </div>
                                    <span class="badge badge-primary">${node.type.replace('bpmn:', '')}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : ''}
                    
                    <div style="margin-top: 20px;">
                        <a href="${subprocessFile}.html" style="display: inline-block; padding: 10px 20px; background: #0066cc; color: white; text-decoration: none; border-radius: 6px; font-weight: 600;">
                            üìÑ Visa fullst√§ndig subprocess-dokumentation ‚Üí
                        </a>
                    </div>
                </div>
                ` : ''}
            </div>
        </section>
        ` : ''}

        <section>
            <h2>üîó L√§nkar och Resurser</h2>
            <div class="card">
                <p><em>L√§nkar till Figma, Jira, Confluence och tester l√§ggs till via BPMN-viewern</em></p>
            </div>
        </section>

        ${dorDodCriteria.length ? `
        <section>
            <h2>‚úÖ Definition of Ready / Definition of Done ‚Äì krav</h2>
            <div class="card">
                <p style="margin-bottom: 10px;">
                    Nedan listas statiska DoR/DoD-krav kopplade till denna nods typ och sammanhang. 
                    Dessa √§r avsedda som st√∂d vid planering, utveckling och kvalitetss√§kring.
                </p>
                <ul style="margin-left: 1.5rem; margin-top: 10px; display: flex; flex-direction: column; gap: 6px;">
                    ${dorDodCriteria.map((criterion) => `
                        <li>
                            <strong>[${criterion.criterion_type.toUpperCase()} ‚Äì ${criterion.criterion_category}]</strong>
                            &nbsp;${criterion.criterion_text}
                        </li>
                    `).join('')}
                </ul>
            </div>
        </section>
        ` : ''}
    </div>
</body>
</html>`;

  return html;
}

// ============= BATCH GENERATOR =============

interface NodeArtifactEntry {
  bpmnFile: string;
  elementId: string;
  elementName: string;
  docFileName?: string;
  testFileName?: string;
}

export interface GenerationResult {
  tests: Map<string, string>;
  docs: Map<string, string>;
  dorDod: Map<string, DorDodCriterion[]>;
  subprocessMappings: Map<string, string | null>;
  nodeArtifacts?: NodeArtifactEntry[];
  metadata?: {
    hierarchyUsed: boolean;
    totalFilesAnalyzed?: number;
    filesIncluded?: string[];
    hierarchyDepth?: number;
    missingDependencies?: { parent: string; childProcess: string }[];
    skippedSubprocesses?: string[];
    llmFallbackUsed?: boolean;
    llmFinalProvider?: LlmProvider;
  };
}

type PlannedScenarioProvider = 'claude' | 'chatgpt' | 'ollama';
type PlannedScenarioMap = Map<string, Map<PlannedScenarioProvider, TestScenario[]>>;
const FALLBACK_PROVIDER_ORDER: PlannedScenarioProvider[] = [
  'claude',
  'chatgpt', // Legacy
  'ollama',
];
const mapTestScenarioToSkeleton = (scenario: TestScenario) => ({
  name:
    scenario.id && scenario.name && scenario.id !== scenario.name
      ? `${scenario.id} ‚Äì ${scenario.name}`
      : scenario.name || scenario.id || 'Scenario',
  description: scenario.description || '',
});

function mapProviderToScenarioProvider(
  provider: LlmProvider,
  fallbackUsed: boolean,
): PlannedScenarioProvider | null {
  if (provider === 'cloud') return 'claude';
  if (provider === 'ollama') return 'ollama';
  return null;
}

/**
 * Builds test scenarios from Epic user stories.
 * Converts user stories with acceptance criteria to test scenarios for the database.
 */
function buildScenariosFromEpicUserStories(
  docJson: any,
): import('@/data/testMapping').TestScenario[] {
  if (!docJson || typeof docJson !== 'object') return [];
  const rawUserStories = Array.isArray(docJson.userStories) ? docJson.userStories : [];
  const scenarios: import('@/data/testMapping').TestScenario[] = [];

  for (const userStory of rawUserStories) {
    if (!userStory || typeof userStory !== 'object') continue;
    
    const storyId = typeof userStory.id === 'string' && userStory.id.trim().length
      ? userStory.id.trim()
      : `US-${scenarios.length + 1}`;
    
    const role = typeof userStory.role === 'string' ? userStory.role.trim() : '';
    const goal = typeof userStory.goal === 'string' ? userStory.goal.trim() : '';
    const value = typeof userStory.value === 'string' ? userStory.value.trim() : '';
    const acceptanceCriteria = Array.isArray(userStory.acceptanceCriteria) 
      ? userStory.acceptanceCriteria 
      : [];

    // Create one scenario per user story
    // Description includes the user story format and acceptance criteria
    const storyDescription = `Som ${role} vill jag ${goal} s√• att ${value}`;
    const criteriaText = acceptanceCriteria.length > 0
      ? `\n\nAcceptanskriterier:\n${acceptanceCriteria.map((ac: string, idx: number) => `${idx + 1}. ${ac}`).join('\n')}`
      : '';
    
    const description = `${storyDescription}${criteriaText}`;

    // Determine category based on acceptance criteria content
    // Happy path: positive criteria, Edge: validation/edge cases, Error: error handling
    let category: 'happy-path' | 'edge-case' | 'error-case' = 'happy-path';
    const criteriaTextLower = criteriaText.toLowerCase();
    if (criteriaTextLower.includes('fel') || criteriaTextLower.includes('error') || criteriaTextLower.includes('timeout')) {
      category = 'error-case';
    } else if (criteriaTextLower.includes('validera') || criteriaTextLower.includes('edge') || criteriaTextLower.includes('gr√§ns')) {
      category = 'edge-case';
    }

    scenarios.push({
      id: storyId,
      name: `User Story: ${goal}`,
      description,
      status: 'pending',
      category,
    });
  }

  return scenarios;
}

/**
 * Builds test scenarios from docJson.
 * For Epics: uses user stories
 * For Feature Goals and Business Rules: returns empty array (scenarios removed)
 */
function buildScenariosFromDocJson(
  docType: DocumentationDocType,
  docJson: any,
): import('@/data/testMapping').TestScenario[] {
  if (!docJson || typeof docJson !== 'object') return [];
  
  // For epics, use user stories
  if (docType === 'epic') {
    return buildScenariosFromEpicUserStories(docJson);
  }
  
  // Feature Goals and Business Rules no longer have scenarios
  return [];
}

/**
 * Bygger enklare LLM-scenarion f√∂r test-skeletons direkt fr√•n docJson.
 * F√∂r Epics: anv√§nder userStories
 * F√∂r Feature Goals/Business Rules: returnerar tom array (scenarios borttagna)
 * Anv√§nds som f√∂rsta steg i pipen:
 *   docJson.userStories ‚Üí Playwright-skelett
 * utan att g√∂ra ett separat LLM-anrop f√∂r testscript.
 */
function buildTestSkeletonScenariosFromDocJson(
  docType: DocumentationDocType,
  docJson: any,
): { name: string; description: string; expectedResult?: string; steps?: string[] }[] {
  if (!docJson || typeof docJson !== 'object') return [];
  
  // For epics, use user stories
  if (docType === 'epic') {
    const rawUserStories = Array.isArray(docJson.userStories) ? docJson.userStories : [];
    const scenarios: { name: string; description: string; expectedResult?: string; steps?: string[] }[] = [];

    for (const userStory of rawUserStories) {
      if (!userStory || typeof userStory !== 'object') continue;
      
      const storyId = typeof userStory.id === 'string' && userStory.id.trim().length
        ? userStory.id.trim()
        : `US-${scenarios.length + 1}`;
      
      const role = typeof userStory.role === 'string' ? userStory.role.trim() : '';
      const goal = typeof userStory.goal === 'string' ? userStory.goal.trim() : '';
      const value = typeof userStory.value === 'string' ? userStory.value.trim() : '';
      const acceptanceCriteria = Array.isArray(userStory.acceptanceCriteria) 
        ? userStory.acceptanceCriteria 
        : [];

      const name = `User Story ${storyId}: ${goal}`;
      const storyDescription = `Som ${role} vill jag ${goal} s√• att ${value}`;
      const criteriaText = acceptanceCriteria.length > 0
        ? `\n\nAcceptanskriterier:\n${acceptanceCriteria.map((ac: string) => `- ${ac}`).join('\n')}`
        : '';
      
      const description = `${storyDescription}${criteriaText}`;

      scenarios.push({
        name,
        description,
        expectedResult: description,
        // steps l√§mnas tomma s√• generateTestSkeleton genererar generiska TODO-kommentarer
      });
    }

    return scenarios;
  }
  
  // Feature Goals and Business Rules no longer have scenarios
  return [];
}

/**
 * Generates documentation using LLM. REQUIRES LLM to work - no fallback.
 * If LLM is disabled or fails, throws an error.
 */
async function renderDocWithLlm(
  docType: DocumentationDocType,
  context: NodeDocumentationContext,
  links: TemplateLinks,
  llmAllowed: boolean,
  llmProvider?: LlmProvider,
  onLlmResult?: (provider: LlmProvider, fallbackUsed: boolean, docJson?: unknown) => void,
  childrenDocumentation?: Map<string, {
    summary: string;
    flowSteps: string[];
    inputs?: string[];
    outputs?: string[];
  }>,
  structuralInfo?: { paths: ProcessPath[]; flowGraph?: FlowGraph },
  checkCancellation?: () => void,
  abortSignal?: AbortSignal,
): Promise<string> {
  const llmActive = llmAllowed && isLlmEnabled();
  const basePayload = {
    docType,
    nodeId: context.node.bpmnElementId,
    nodeName: context.node.name,
    bpmnFile: context.node.bpmnFile,
  };

  // LLM m√•ste vara aktivt - inga fallbacks
  if (!llmActive) {
    throw new Error(`LLM is required for ${docType} documentation generation but is disabled or not available`);
  }

  // Kontrollera avbrytning INNAN LLM-anrop
  if (checkCancellation) {
    checkCancellation();
  }

  try {
    // Convert childrenDocumentation to ChildNodeDocumentation format if needed
    const convertedChildrenDoc = childrenDocumentation ? new Map<string, ChildNodeDocumentation>() : undefined;
    if (childrenDocumentation && convertedChildrenDoc) {
      // We need to get node info from graph, but for now we'll create a minimal conversion
      // The actual conversion should happen at the call site where we have node information
      for (const [key, value] of childrenDocumentation.entries()) {
        convertedChildrenDoc.set(key, {
          id: key,
          name: key,
          type: 'unknown',
          summary: value.summary,
          flowSteps: value.flowSteps,
          inputs: value.inputs,
          outputs: value.outputs,
        });
      }
    }
    
    const llmResult = await generateDocumentationWithLlm(
      docType,
      context,
      links,
      llmProvider,
      false, // localAvailable
      true, // allowFallback
      convertedChildrenDoc,
      abortSignal, // Pass abort signal for LLM calls
      structuralInfo, // structuralInfo
    );
    
    if (!llmResult || !llmResult.text || !llmResult.text.trim()) {
      throw new Error(`LLM returned empty response for ${docType} documentation (${context.node.bpmnFile}::${context.node.bpmnElementId})`);
    }

    onLlmResult?.(llmResult.provider, llmResult.fallbackUsed, llmResult.docJson);
    // H√§mta provider-info f√∂r metadata fr√•n faktisk provider
    const llmClient = getLlmClient(llmResult.provider);
    
    // Map provider to 'cloud' | 'local' for LlmMetadata
    const providerForMetadata: 'cloud' | 'local' = 
      llmClient.provider === 'cloud' ? 'cloud' : 'local';
    const finalProviderForMetadata: 'cloud' | 'local' = 
      llmResult.provider === 'cloud' ? 'cloud' : 'local';
    
    const llmMetadata = {
      llmMetadata: {
        provider: providerForMetadata,
        model: llmClient.modelName,
      },
      fallbackUsed: llmResult.fallbackUsed,
      finalProvider: finalProviderForMetadata,
    };

    // Use unified render functions - they handle base + overrides + LLM patch
    if (docType === 'feature') {
      return await renderFeatureGoalDoc(context, links, llmResult.text, llmMetadata);
    }

    if (docType === 'epic') {
      return await renderEpicDoc(context, links, llmResult.text, llmMetadata);
    }

    if (docType === 'businessRule') {
      return await renderBusinessRuleDoc(context, links, llmResult.text, llmMetadata);
    }

    const identifier = `${context.node.bpmnFile || 'unknown'}-${context.node.bpmnElementId || context.node.id}`;
    await saveLlmDebugArtifact('doc', identifier, llmResult.text);
    const title =
      context.node.name ||
      context.node.bpmnElementId ||
      (docType === 'feature'
        ? 'Feature'
        : docType === 'epic'
        ? 'Epic'
        : 'Business Rule');
    const wrapped = wrapLlmContentAsDocument(llmResult.text, title, { docType });
    if (!/<html[\s>]/i.test(wrapped) || !/<body[\s>]/i.test(wrapped)) {
      throw new Error(`LLM returned invalid HTML for ${docType} documentation (${context.node.bpmnFile}::${context.node.bpmnElementId})`);
    }
    return wrapped;
  } catch (error) {
    console.error(`[LLM Documentation] Failed to generate ${docType} documentation for ${context.node.bpmnFile}::${context.node.bpmnElementId}:`, error);
    await logLlmFallback({
      eventType: 'documentation',
      status: 'error',
      reason: error instanceof Error ? error.message : 'unknown-error',
      error,
      ...basePayload,
    });
    // Kasta fel vidare - inga fallbacks
    throw error;
  }
}

async function parseSubprocessFile(fileName: string): Promise<SubprocessSummary | null> {
  try {
    const url = await getBpmnFileUrl(fileName);
    const result = await parseBpmnFile(url);
    
    // Count different node types
    const userTasks = result.elements.filter(e => e.type === 'bpmn:UserTask').length;
    const serviceTasks = result.elements.filter(e => e.type === 'bpmn:ServiceTask').length;
    const businessRuleTasks = result.elements.filter(e => e.type === 'bpmn:BusinessRuleTask').length;
    const gateways = result.elements.filter(e => 
      e.type.includes('Gateway') && 
      !e.type.includes('EventBased')
    ).length;
    
    // Get key nodes (UserTasks, ServiceTasks, BusinessRuleTasks)
    const keyNodeTypes = ['bpmn:UserTask', 'bpmn:ServiceTask', 'bpmn:BusinessRuleTask'];
    const keyNodes = result.elements
      .filter(e => keyNodeTypes.includes(e.type))
      .slice(0, 10) // Limit to first 10 key nodes
      .map(e => ({
        id: e.id,
        name: e.name,
        type: e.type,
      }));
    
    return {
      fileName,
      totalNodes: result.elements.filter(e => 
        !e.type.includes('Process') && 
        !e.type.includes('Collaboration') &&
        e.type !== 'label'
      ).length,
      userTasks,
      serviceTasks,
      businessRuleTasks,
      gateways,
      keyNodes,
    };
  } catch (error) {
    console.error(`Error parsing subprocess ${fileName}:`, error);
    return null;
  }
}

async function parseDmnSummary(fileName: string): Promise<SubprocessSummary | null> {
  try {
    const response = await fetch(`/dmn/${fileName}`);
    if (!response.ok) return null;
    
    const xml = await response.text();
    const { parseDmnFile } = await import('./dmnParser');
    const result = await parseDmnFile(`/dmn/${fileName}`);
    
    if (result.decisionTables.length === 0) return null;
    
    const table = result.decisionTables[0]; // Use first decision table
    
    // Map DMN data to SubprocessSummary format
    // totalNodes = number of rules
    // userTasks = input columns
    // serviceTasks = output columns
    // keyNodes = input column details
    
    const keyNodes = table.inputs.map(input => ({
      id: input.id,
      name: input.label || input.inputExpression || 'Input',
      type: input.typeRef || 'string',
    }));
    
    return {
      fileName,
      totalNodes: table.rules.length,
      userTasks: table.inputs.length,
      serviceTasks: table.outputs.length,
      businessRuleTasks: 0,
      gateways: 0,
      keyNodes,
    };
  } catch (error) {
    console.error(`Error parsing DMN ${fileName}:`, error);
    return null;
  }
}

/**
 * Genererar alla artefakter fr√•n en BPMN-processgraf.
 * Denna funktion anv√§nder en hierarkisk analys f√∂r att ge b√§ttre kontext.
 * 
 * @param bpmnFileName - Fil att generera f√∂r
 * @param existingBpmnFiles - Alla tillg√§ngliga BPMN-filer
 * @param existingDmnFiles - Alla tillg√§ngliga DMN-filer
 * @param useHierarchy - Om true, bygg processgraf f√∂rst (rekommenderat f√∂r toppniv√•filer)
 */
type ProgressReporter = (phase: GenerationPhaseKey, label: string, detail?: string) => void | Promise<void>;

const insertGenerationMeta = (html: string, source: string): string => {
  if (!source) return html;
  if (html.includes('x-generation-source')) return html;
  const metaTag = `<meta name="x-generation-source" content="${source}" />`;
  if (html.includes('<head>')) {
    return html.replace('<head>', `<head>\n  ${metaTag}`);
  }
  return `<!-- generation-source:${source} -->\n${html}`;
};

/**
 * Extraherar dokumentationsinformation fr√•n docJson f√∂r att spara i generatedChildDocs
 */
function extractDocInfoFromJson(docJson: unknown): {
  summary: string;
  flowSteps: string[];
  inputs?: string[];
  outputs?: string[];
  scenarios?: Array<{ id: string; name: string; type: string; outcome: string }>;
} | null {
  if (!docJson || typeof docJson !== 'object') return null;
  
  const obj = docJson as any;
  return {
    summary: obj.summary || '',
    flowSteps: Array.isArray(obj.flowSteps) ? obj.flowSteps : [],
    inputs: Array.isArray(obj.inputs) ? obj.inputs : undefined,
    outputs: Array.isArray(obj.outputs) ? obj.outputs : undefined,
    scenarios: Array.isArray(obj.scenarios) ? obj.scenarios : undefined,
  };
}

/**
 * F√∂rs√∂ker ladda child documentation fr√•n befintlig dokumentation i Storage
 * Detta anv√§nds n√§r leaf nodes hoppas √∂ver f√∂r att fortfarande kunna samla
 * child documentation f√∂r Feature Goals.
 */
async function loadChildDocFromStorage(
  bpmnFile: string,
  elementId: string,
  docFileKey: string,
  versionHash: string | null,
  generationSourceLabel: string
): Promise<{
  summary: string;
  flowSteps: string[];
  inputs?: string[];
  outputs?: string[];
  scenarios?: Array<{ id: string; name: string; type: string; outcome: string }>;
} | null> {
  try {
    // F√∂rs√∂k ladda JSON fr√•n llm-debug/docs-raw/ f√∂rst (snabbast och mest komplett)
    const identifier = `${bpmnFile}-${elementId}`;
    const safeId = identifier.toLowerCase().replace(/[^a-z0-9._-]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    
    const { data: rawFiles, error: rawError } = await supabase.storage
      .from('bpmn-files')
      .list('llm-debug/docs-raw', {
        search: safeId,
        limit: 100,
      });
    
    if (!rawError && rawFiles && rawFiles.length > 0) {
      // Sortera manuellt efter created_at (nyaste f√∂rst)
      rawFiles.sort((a, b) => {
        const timeA = a.created_at ? new Date(a.created_at).getTime() : 0;
        const timeB = b.created_at ? new Date(b.created_at).getTime() : 0;
        return timeB - timeA;
      });
      
      const latestRawFile = rawFiles[0];
      const { data: rawData, error: downloadError } = await supabase.storage
        .from('bpmn-files')
        .download(`llm-debug/docs-raw/${latestRawFile.name}`);
      
      if (!downloadError && rawData) {
        const rawText = await rawData.text();
        try {
          // Parse JSON fr√•n raw text (anv√§nd samma logik som i llmDocumentation.ts)
          let jsonText = rawText.trim();
          jsonText = jsonText.replace(/```(?:json|javascript)?/gi, '').replace(/```/g, '').trim();
          jsonText = jsonText.replace(/\/\/.*$/gm, '');
          jsonText = jsonText.replace(/\/\*[\s\S]*?\*\//g, '');
          
          const firstBrace = jsonText.indexOf('{');
          if (firstBrace >= 0) {
            jsonText = jsonText.slice(firstBrace);
            let braceCount = 0;
            let end = -1;
            for (let i = 0; i < jsonText.length; i++) {
              if (jsonText[i] === '{') braceCount++;
              if (jsonText[i] === '}') {
                braceCount--;
                if (braceCount === 0) {
                  end = i + 1;
                  break;
                }
              }
            }
            if (end > 0) {
              jsonText = jsonText.slice(0, end);
            }
          }
          
          const docJson = JSON.parse(jsonText);
          const docInfo = extractDocInfoFromJson(docJson);
          if (docInfo) {
            if (import.meta.env.DEV) {
              console.log(`[bpmnGenerators] ‚úÖ Loaded child doc from llm-debug/docs-raw for ${elementId}`);
            }
            return docInfo;
          }
        } catch (parseError) {
          // Ignorera parse-fel, f√∂rs√∂k n√§sta metod
          if (import.meta.env.DEV) {
            console.warn(`[bpmnGenerators] Could not parse JSON from llm-debug/docs-raw for ${elementId}:`, parseError);
          }
        }
      }
    }
    
    // Fallback: F√∂rs√∂k ladda HTML och extrahera information (mer komplext, g√∂rs senare om beh√∂vs)
    // F√∂r nu, returnera null s√• att Feature Goals samlar fr√•n andra noder som faktiskt genereras
    
    return null;
  } catch (error) {
    if (import.meta.env.DEV) {
      console.warn(`[bpmnGenerators] Error loading child doc from Storage for ${elementId}:`, error);
    }
    return null;
  }
}

export async function generateAllFromBpmnWithGraph(
  bpmnFileName: string,
  existingBpmnFiles: string[],
  existingDmnFiles: string[] = [],
  useHierarchy: boolean = false,
  useLlm: boolean = true,
  progressCallback?: ProgressReporter,
  generationSource?: string,
  llmProvider?: LlmProvider,
  /**
   * Optional filter function to determine which nodes should be generated.
   * Returns true if node should be generated, false to skip.
   * If not provided, all nodes are generated (default behavior).
   */
  nodeFilter?: (node: BpmnProcessNode) => boolean,
  /**
   * Optional function to get version hash for a BPMN file.
   * If provided, uses selected version instead of current version.
   */
  getVersionHashForFile?: (fileName: string) => Promise<string | null>,
  /**
   * Optional function to check if generation should be cancelled.
   * Should throw an error if cancellation is requested.
   */
  checkCancellation?: () => void,
  /**
   * Optional AbortSignal for cancelling LLM API calls.
   * Used to abort ongoing fetch requests (local LLM) and check before cloud LLM calls.
   */
  abortSignal?: AbortSignal,
  /**
   * Optional flag to indicate if this is the actual root file of the entire hierarchy.
   * If not provided, will be inferred from graphFileScope length.
   */
  isActualRootFile?: boolean,
  /**
   * Optional flag to force regeneration even if documentation already exists in Storage.
   * When true, Storage existence checks are bypassed and all nodes matching nodeFilter are regenerated.
   * Default: false (respects Storage existence checks).
   */
  forceRegenerate?: boolean,
): Promise<GenerationResult> {
  const reportProgress = async (phase: GenerationPhaseKey, label: string, detail?: string) => {
    if (progressCallback) {
      await progressCallback(phase, label, detail);
    }
  };
  const generationSourceLabel = generationSource ?? (useLlm ? 'llm' : 'local');
  const graphFileScope =
    useHierarchy && existingBpmnFiles.length > 0 ? existingBpmnFiles : [bpmnFileName];

  try {
    await reportProgress('graph:start', 'Analyserar BPMN-struktur', bpmnFileName);
    
    // Get version hashes for all files in scope
    const versionHashes = new Map<string, string | null>();
    if (getVersionHashForFile) {
      for (const fileName of graphFileScope) {
        try {
          const versionHash = await getVersionHashForFile(fileName);
          versionHashes.set(fileName, versionHash);
        } catch (error) {
          console.warn(`[generateAllFromBpmnWithGraph] Failed to get version hash for ${fileName}:`, error);
          versionHashes.set(fileName, null);
        }
      }
    }
    const graph = await buildBpmnProcessGraph(bpmnFileName, graphFileScope, versionHashes);
    const summary = createGraphSummary(graph);
    
    // Ladda bpmn-map f√∂r att avg√∂ra om en fil √§r root-process
    let rootProcessId: string | null = null;
    try {
      const { loadBpmnMap } = await import('@/lib/bpmn/bpmnMapLoader');
      const { loadBpmnMapFromStorage } = await import('@/lib/bpmn/bpmnMapStorage');
      const bpmnMapResult = await loadBpmnMapFromStorage();
      if (bpmnMapResult.valid && bpmnMapResult.map) {
        rootProcessId = bpmnMapResult.map.orchestration?.root_process || null;
      }
    } catch (error) {
      // Om bpmn-map inte kan laddas, anv√§nd fallback-logik
      console.warn('[bpmnGenerators] Could not load bpmn-map.json, using fallback root detection:', error);
    }
    // OBS: Om nodeFilter finns, betyder det att vi bara vill generera f√∂r specifika noder.
    // I s√• fall, begr√§nsa analyzedFiles till bara den fil som anv√§ndaren valde,
    // √§ven om useHierarchy = true (hierarki anv√§nds f√∂r kontext, men vi genererar bara f√∂r vald fil).
    // VIKTIGT: analyzedFiles best√§mmer vilka filer som f√•r dokumentation genererad.
    // Om useHierarchy = true, anv√§nds hierarkin f√∂r att bygga graf med kontext,
    // men dokumentation ska bara genereras f√∂r den valda filen (bpmnFileName),
    // inte f√∂r alla filer i hierarkin.
    // 
    // Undantag: Om nodeFilter saknas OCH useHierarchy = true OCH bpmnFileName √§r root-fil,
    // d√• kan vi generera f√∂r alla filer i hierarkin (fullst√§ndig generering).
    // 
    // F√∂r subprocesser (t.ex. Household): generera BARA f√∂r subprocess-filen,
    // √§ven om parent-filen inkluderas i grafen f√∂r kontext.
    // 
    // VIKTIGT: N√§r en subprocess genereras isolerat, blir den f√∂rsta filen i summary.filesIncluded
    // (eftersom grafen byggs med subprocess som root). Men det betyder INTE att det √§r root-fil-generering.
    // Vi m√•ste kolla om filen faktiskt √§r root-filen i hela hierarkin, inte bara i den isolerade grafen.
    // 
    // Indikatorer f√∂r root-fil-generering:
    // 1. isActualRootFile flag √§r satt till true (explicit fr√•n anroparen)
    // 2. ELLER graphFileScope inneh√•ller m√•nga filer (hela hierarkin, typ >5 filer)
    // 3. OCH summary.filesIncluded inneh√•ller m√•nga filer (hela hierarkin)
    // 4. OCH bpmnFileName √§r f√∂rsta filen i summary.filesIncluded
    // 
    // Om graphFileScope bara inneh√•ller 1-4 filer (subprocess + parent + siblings), √§r det isolerad generering.
    // Best√§m om detta √§r root-fil-generering (generera f√∂r hela hierarkin)
    // Detta sker n√§r:
    // 1. useHierarchy = true (hierarki anv√§nds)
    // 2. Ingen nodeFilter (generera allt)
    // 3. Root-filen matchar f√∂rsta filen i hierarkin
    // 4. Antingen isActualRootFile = true ELLER det finns flera filer i scope (hierarkisk struktur)
    const isRootFileGeneration = useHierarchy && 
      !nodeFilter && 
      summary.filesIncluded.length > 0 &&
      summary.filesIncluded[0] === bpmnFileName &&
      (isActualRootFile === true || graphFileScope.length > 1); // Root-fil-generering = flera filer i scope (hierarki)
    
    // VIKTIGT: N√§r isRootFileGeneration = true, vill vi generera f√∂r ALLA filer i hierarkin.
    // Men summary.filesIncluded kan bara inneh√•lla filer som faktiskt har noder i grafen.
    // Om en fil bara har en process-nod (inga tasks/callActivities), s√• kommer den inte
    // att vara med i summary.filesIncluded, men vi m√•ste fortfarande generera Feature Goal f√∂r den.
    // VIKTIGT: Anv√§nd ALLTID graphFileScope f√∂r isRootFileGeneration, eftersom den inneh√•ller
    // alla filer som skickades in till buildBpmnProcessGraph, √§ven de som bara har process-noder.
    const analyzedFiles = isRootFileGeneration
      ? graphFileScope // Anv√§nd ALLTID graphFileScope f√∂r att s√§kerst√§lla att alla filer bearbetas
      : [bpmnFileName]; // Generera bara f√∂r vald fil (hierarki anv√§nds bara f√∂r kontext)
    
    // Debug logging for analyzedFiles
    if (import.meta.env.DEV) {
      console.log(`[bpmnGenerators] analyzedFiles determined:`, {
        isRootFileGeneration,
        summaryFilesIncluded: summary.filesIncluded,
        graphFileScopeLength: graphFileScope.length,
        analyzedFiles,
        bpmnFileName,
      });
    }
    
    // Logga varning om hierarki anv√§nds men inga filer hittades
    if (useHierarchy && summary.filesIncluded.length === 0) {
      console.warn(
        `[generateAllFromBpmnWithGraph] useHierarchy=true but no files found in summary.filesIncluded. Falling back to [${bpmnFileName}]`
      );
    }
    const totalAnalyzed = useHierarchy ? summary.totalFiles : analyzedFiles.length;
    await reportProgress(
      'graph:complete',
      'Processtr√§d klart',
      `${totalAnalyzed} filer ¬∑ djup ${summary.hierarchyDepth}`,
    );
    
    const testableNodes = getTestableNodes(graph);
    
    // Filtrera testableNodes till bara de som ska genereras (baserat p√• analyzedFiles)
    // Detta s√§kerst√§ller att progress-r√§kningen matchar faktiskt antal noder som genereras
    // VIKTIGT: F√∂r callActivities, inkludera dem BARA om:
    // 1. CallActivity-filen √§r med i analyzedFiles
    // 2. Subprocess-filen finns (node.missingDefinition = false)
    // 3. Subprocess-filen finns i existingBpmnFiles (extra s√§kerhet)
    // Om subprocess-filen saknas, hoppa √∂ver callActivity (kan inte generera korrekt dokumentation)
    const nodesToGenerate = testableNodes.filter(node => {
      // Om nodeFilter finns, anv√§nd den f√∂rst
      if (nodeFilter && !nodeFilter(node)) {
        return false;
      }
      
      // F√∂r callActivities: kolla b√•de callActivity-filen OCH om subprocess-filen finns
      if (node.type === 'callActivity') {
        const callActivityFileIncluded = analyzedFiles.includes(node.bpmnFile);
        
        // VIKTIGT: Om subprocess-filen saknas (missingDefinition = true), hoppa √∂ver callActivity
        // Detta s√§kerst√§ller att vi bara genererar Feature Goals n√§r subprocess-filen faktiskt finns
        if (node.missingDefinition) {
          // Subprocess-filen saknas - hoppa √∂ver callActivity
          if (import.meta.env.DEV) {
            console.warn(
              `[bpmnGenerators] ‚ö†Ô∏è Skipping callActivity ${node.bpmnElementId} ` +
              `(subprocess file ${node.subprocessFile || 'unknown'} not found)`
            );
          }
          return false;
        }
        
        // Verifiera ocks√• att subprocess-filen finns i existingBpmnFiles (extra s√§kerhet)
        if (node.subprocessFile && !existingBpmnFiles.includes(node.subprocessFile)) {
          if (import.meta.env.DEV) {
            console.warn(
              `[bpmnGenerators] ‚ö†Ô∏è Skipping callActivity ${node.bpmnElementId} ` +
              `(subprocess file ${node.subprocessFile} not in existingBpmnFiles)`
            );
          }
          return false;
        }
        
        return callActivityFileIncluded;
      }
      
      // F√∂r tasks/epics: inkludera bara om filen √§r med i analyzedFiles
      return analyzedFiles.includes(node.bpmnFile);
    });

    // Ber√§kna depth f√∂r varje nod (f√∂r hierarkisk generering: leaf nodes f√∂rst)
    // OBS: Anv√§nd nodesToGenerate (filtrerade noder) f√∂r depth-ber√§kning
    const nodeDepthMap = new Map<string, number>();
    const calculateNodeDepth = (node: BpmnProcessNode, visited = new Set<string>()): number => {
      if (visited.has(node.id)) return 0; // Avoid cycles
      visited.add(node.id);
      
      if (!node.children || node.children.length === 0) {
        nodeDepthMap.set(node.id, 0);
        return 0;
      }
      
      const maxChildDepth = Math.max(
        ...node.children.map(child => calculateNodeDepth(child, visited))
      );
      const depth = maxChildDepth + 1;
      nodeDepthMap.set(node.id, depth);
      return depth;
    };
    
    // Ber√§kna depth f√∂r alla noder som ska genereras
    for (const node of nodesToGenerate) {
      if (!nodeDepthMap.has(node.id)) {
        calculateNodeDepth(node);
      }
    }

    // Generera artefakter fr√•n grafen
    const result: GenerationResult = {
      tests: new Map(),
      docs: new Map(),
      dorDod: new Map(),
      subprocessMappings: new Map(),
      metadata: {
        hierarchyUsed: true,
        totalFilesAnalyzed: totalAnalyzed,
        filesIncluded: analyzedFiles,
        hierarchyDepth: summary.hierarchyDepth,
        missingDependencies: graph.missingDependencies,
        skippedSubprocesses: Array.from(
          new Set(graph.missingDependencies.map((dep) => dep.childProcess)),
        ),
      },
    };
    const hierarchicalNodeArtifacts: NodeArtifactEntry[] = [];
    result.nodeArtifacts = hierarchicalNodeArtifacts;
    // Track LLM provider fallback usage (when first provider fails and alternative provider is used)
    // Note: This is NOT the same as template fallback (fallback() function) which is used when ALL LLM fails
    // llmFallbackUsed = true means: LLM worked but had to fallback from one provider to another (e.g. local ‚Üí cloud)
    let llmFallbackUsed = false;
    let llmFinalProvider: LlmProvider | undefined = undefined;
    const plannedScenarioMap: PlannedScenarioMap = new Map();
    const setScenarioEntry = (
      key: string,
      provider: PlannedScenarioProvider,
      scenarios: TestScenario[],
    ) => {
      if (!plannedScenarioMap.has(key)) {
        plannedScenarioMap.set(key, new Map());
      }
      plannedScenarioMap.get(key)!.set(provider, scenarios);
    };
    const hydrateScenarioMapFromRows = (rows: PlannedScenarioRow[]) => {
      rows.forEach((row) => {
        const provider = row.provider as PlannedScenarioProvider;
        setScenarioEntry(`${row.bpmn_file}::${row.bpmn_element_id}`, provider, row.scenarios);
      });
    };

    // === TESTGENERERING HAR FLYTTATS TILL SEPARAT STEG ===
    // Testfiler och testscenarion genereras inte l√§ngre i dokumentationssteget.
    // Anv√§nd separat testgenereringsfunktion ist√§llet.

    // === DOR/DOD OCH SUBPROCESS MAPPINGS ===
    // Testbara noder fr√•n hela grafen (f√∂r DoR/DoD och subprocess mappings)
    await reportProgress('node-analysis:start', 'Analyserar noder f√∂r artefakter', `${testableNodes.length} noder`);
    
    for (const node of testableNodes) {
      if (!node.element) continue;
      await reportProgress('node-analysis:node', 'Analyserar nod', node.name || node.bpmnElementId);
      
      const nodeType = node.type as 'userTask' | 'serviceTask' | 'businessRuleTask' | 'callActivity';
      
      // Generera DoR/DoD
      const normalizedName = (node.name || node.bpmnElementId)
        .toLowerCase()
        .trim()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, '');
      
      const typeMap: Record<string, 'ServiceTask' | 'UserTask' | 'BusinessRuleTask' | 'CallActivity'> = {
        'userTask': 'UserTask',
        'serviceTask': 'ServiceTask',
        'businessRuleTask': 'BusinessRuleTask',
        'callActivity': 'CallActivity',
      };
      
      const mappedType = typeMap[nodeType];
      if (mappedType) {
        const criteria = generateDorDodForNodeType(mappedType, normalizedName);
        const enrichedCriteria = criteria.map(c => ({
          ...c,
          node_type: mappedType,
          bpmn_element_id: node.bpmnElementId,
          bpmn_file: node.bpmnFile,
        }));
        result.dorDod.set(`${node.bpmnFile}:${node.bpmnElementId}`, enrichedCriteria);
      }

      // Subprocess mappings
      if (node.type === 'callActivity' && node.subprocessFile) {
        const childFile = node.subprocessFile;
        if (childFile) {
          result.subprocessMappings.set(node.bpmnElementId, childFile);
        }
      }
    }
    // Anv√§nd nodesToGenerate.length f√∂r att visa korrekt antal noder som ska genereras
    await reportProgress('node-analysis:complete', 'Nodanalyser klara', `${nodesToGenerate.length} noder`);

    // Seed node_planned_scenarios med bas-scenarion (legacy - anv√§nds inte l√§ngre)
    // OBS: Dessa √§r endast fallback-scenarion. Nya scenarion genereras fr√•n BPMN-filerna
    // via LLM eller fr√•n dokumentationen, och prioriteras √∂ver dessa.
    // OBS: Anv√§nd nodesToGenerate (filtrerade noder) f√∂r att bara skapa scenarion f√∂r noder som genereras
    try {
      const rows = createPlannedScenariosFromGraph(nodesToGenerate);
      // L√§gg till i map f√∂r fallback, men prioritera inte dessa √∂ver LLM-genererade
      hydrateScenarioMapFromRows(rows);
      // Spara endast om det inte redan finns scenarion i databasen (f√∂r att inte skriva √∂ver manuellt skapade)
      // Men n√§r vi genererar dokumentation, kommer LLM-scenarion alltid prioriteras
      await savePlannedScenarios(rows, 'bpmnGenerators');
    } catch (e) {
      console.error(
        '[bpmnGenerators] Failed to seed planned scenarios from hierarchy',
        e,
        'Testable nodes:',
        testableNodes.length,
      );
    }

    // R√§kna process nodes som kommer att genereras (subprocess-filer med process nodes men inga tasks/callActivities)
    // Dessa genereras separat och m√•ste inkluderas i progress-r√§kningen
    // VIKTIGT: Logiken m√•ste matcha exakt logiken f√∂r n√§r process nodes faktiskt genereras (rad 2441-2539)
    let processNodesToGenerate = 0;
    for (const file of analyzedFiles) {
      const hasCallActivityPointingToFile = Array.from(testableNodes.values()).some(
        node => node.type === 'callActivity' && node.subprocessFile === file
      );
      const processNodeForFile = Array.from(graph.allNodes.values()).find(
        node => node.type === 'process' && node.bpmnFile === file
      );
      const fileBaseName = file.replace('.bpmn', '');
      const isRootProcessFromMap = rootProcessId && (fileBaseName === rootProcessId || file === `${rootProcessId}.bpmn`);
      const isSubprocessFile = (hasCallActivityPointingToFile || !!processNodeForFile) && !isRootProcessFromMap;
      
      // R√§kna process node om:
      // 1. Det √§r en subprocess-fil (isSubprocessFile = true)
      // 2. Den har en process node av typ 'process'
      // 3. Den har inga tasks/callActivities i nodesToGenerate (annars genereras Feature Goal via callActivity ist√§llet)
      // Detta matchar exakt logiken i rad 2441: if (isSubprocessFileForSubprocess && processNodeForFileForSubprocess && processNodeForFileForSubprocess.type === 'process')
      const nodesInFile = nodesToGenerate.filter(node => node.bpmnFile === file);
      if (isSubprocessFile && processNodeForFile && processNodeForFile.type === 'process' && nodesInFile.length === 0) {
        processNodesToGenerate++;
        if (import.meta.env.DEV) {
          console.log(`[bpmnGenerators] üìä Counting process node for progress: ${file} (subprocess file with process node but no tasks/callActivities)`);
        }
      }
    }
    
    // Skicka total:init med korrekt antal filer och noder f√∂r progress-r√§kning
    // OBS: Inkludera b√•de nodesToGenerate.length OCH processNodesToGenerate f√∂r korrekt progress-r√§kning
    const totalNodesToGenerate = nodesToGenerate.length + processNodesToGenerate;
    await reportProgress(
      'total:init',
      'Initierar generering',
      JSON.stringify({
        files: analyzedFiles.length,
        nodes: totalNodesToGenerate, // Inkluderar b√•de testable nodes och process nodes
      }),
    );

    // Generera dokumentation per fil (inte per element)
    // STRATEGI: Tv√•-pass generering f√∂r b√§ttre kontext
    // Pass 1: Leaf nodes f√∂rst (h√∂gst depth) - genererar dokumentation f√∂r epics/tasks
    // Pass 2: Parent nodes (l√§gst depth) - genererar Feature Goals med kunskap om child epics
    // NOTE: Dokumentation anv√§nder nodesToGenerate (filtrerade noder) f√∂r korrekt progress-r√§kning
    await reportProgress('docgen:start', 'Genererar dokumentation', `${analyzedFiles.length} filer`);
    const buildMatchWarning = (node: typeof testableNodes[number]) => {
      const reasons: string[] = [];
      if (node.subprocessMatchStatus && node.subprocessMatchStatus !== 'matched') {
        reasons.push(`Subprocess match: ${node.subprocessMatchStatus}`);
      }
      if (node.subprocessDiagnostics?.length) {
        reasons.push(...node.subprocessDiagnostics);
      }
      const reasonText = reasons.length ? reasons.join(' ‚Ä¢ ') : 'Ok√§nd orsak';
      return `<p>Subprocess-kopplingen √§r inte bekr√§ftad. F√∂ljande diagnostik finns:</p><p>${reasonText}</p>`;
    };

    // Map f√∂r att spara genererad dokumentation fr√•n child nodes (anv√§nds i Pass 2)
    const generatedChildDocs = new Map<string, {
      summary: string;
      flowSteps: string[];
      inputs?: string[];
      outputs?: string[];
      scenarios?: Array<{ id: string; name: string; type: string; outcome: string }>;
    }>();
    
    // Global Set f√∂r att sp√•ra vilka subprocesser som redan har genererat Feature Goal-dokumentation
    // Detta f√∂rhindrar dubbelgenerering n√§r samma subprocess anropas fr√•n olika callActivities
    const generatedSubprocessFeatureGoals = new Set<string>(); // subprocessFile -> true
    
    // Global Set f√∂r att sp√•ra vilka noder som redan har genererat dokumentation
    // Detta √§r konsekvent med generatedSubprocessFeatureGoals och f√∂rhindrar dubbelgenerering
    // Key format: f√∂r callActivities: `subprocess:${subprocessFile}`, f√∂r tasks/epics: `${bpmnFile}::${bpmnElementId}`
    const globalProcessedDocNodes = new Set<string>();

    // VIKTIGT: Sortera filer s√• att subprocess-filer genereras F√ñRE parent-filer
    // Detta s√§kerst√§ller att child documentation finns tillg√§nglig n√§r parent Feature Goals genereras
    // Identifiera subprocess-filer (filer som anropas av callActivities)
    const subprocessFiles = new Set<string>();
    for (const node of nodesToGenerate) {
      if (node.type === 'callActivity' && node.subprocessFile) {
        subprocessFiles.add(node.subprocessFile);
      }
    }
    
    // Separera i subprocess-filer och root-filer
    const subprocessFilesList = analyzedFiles.filter(file => subprocessFiles.has(file));
    const rootFilesList = analyzedFiles.filter(file => !subprocessFiles.has(file));
    
    // Sortera varje kategori alfabetiskt f√∂r determinism
    subprocessFilesList.sort((a, b) => a.localeCompare(b));
    rootFilesList.sort((a, b) => a.localeCompare(b));
    
    // Subprocess-filer f√∂rst, sedan root-filer
    const sortedAnalyzedFiles = [...subprocessFilesList, ...rootFilesList];
    
    if (import.meta.env.DEV && sortedAnalyzedFiles.length !== analyzedFiles.length) {
      console.warn(
        `[bpmnGenerators] ‚ö†Ô∏è File order changed: ${analyzedFiles.length} ‚Üí ${sortedAnalyzedFiles.length} files`
      );
    }

    for (const file of sortedAnalyzedFiles) {
      await reportProgress('docgen:file', 'Genererar dokumentation/testinstruktioner', file);
      const docFileName = file.replace('.bpmn', '.html');
      
      // Samla alla noder fr√•n denna fil f√∂r dokumentation
      // OBS: Anv√§nd nodesToGenerate (redan filtrerade) ist√§llet f√∂r testableNodes
      const nodesInFile = nodesToGenerate.filter(node => node.bpmnFile === file);
      
      // Debug-logging endast om inga noder hittades (f√∂r att identifiera problem)
      // KRITISKT: Detta √§r viktigt f√∂r att identifiera filer som bara har process-noder
      if (nodesInFile.length === 0) {
        const processNodeForFile = Array.from(graph.allNodes.values()).find(
          node => node.type === 'process' && node.bpmnFile === file
        );
        if (processNodeForFile) {
          console.warn(`[bpmnGenerators] ‚ö†Ô∏è No tasks/callActivities found for ${file}, but process node exists: ${processNodeForFile.id}`);
        } else {
          console.warn(`[bpmnGenerators] ‚ö†Ô∏è No nodes found for ${file} (no process node either)`);
        }
      }
      
      if (nodesInFile.length > 0) {
        // Sortera noder prim√§rt efter depth (hierarkisk ordning: leaf nodes f√∂rst)
        // Sekund√§rt efter orderIndex (exekveringsordning fr√•n sequence flows) inom samma depth
        // Detta s√§kerst√§ller b√•de hierarkisk ordning OCH exekveringsordning
        // VIKTIGT: Sortera s√• att subprocesser (l√§gre depth) genereras F√ñRE parent processer (h√∂gre depth)
        // Detta s√§kerst√§ller att child documentation finns tillg√§nglig n√§r parent Feature Goal genereras
        const sortedNodesInFile = [...nodesInFile].sort((a, b) => {
          const depthA = nodeDepthMap.get(a.id) ?? 0;
          const depthB = nodeDepthMap.get(b.id) ?? 0;
          
          // Prim√§r sortering: l√§gre depth f√∂rst (subprocesser f√∂re parent nodes)
          // Detta s√§kerst√§ller att child documentation sparas i generatedChildDocs innan parent genereras
          if (depthA !== depthB) {
            return depthA - depthB; // L√ÑGRE DEPTH F√ñRST (inverterat fr√•n tidigare)
          }
          
          // Sekund√§r sortering: orderIndex (exekveringsordning) inom samma depth
          // Anv√§nd orderIndex om det finns, annars visualOrderIndex, annars 0
          const orderA = a.orderIndex ?? a.visualOrderIndex ?? 0;
          const orderB = b.orderIndex ?? b.visualOrderIndex ?? 0;
          
          if (orderA !== orderB) {
            return orderA - orderB; // L√§gre orderIndex f√∂rst (tidigare i exekveringsordningen)
          }
          
          // Terti√§r sortering: alfabetiskt f√∂r determinism
          return (a.name || a.bpmnElementId || '').localeCompare(b.name || b.bpmnElementId || '');
        });
        
        // Skapa en sammanslagen dokumentation f√∂r hela filen ‚Äì med fokus p√• inneh√•ll.
        // Sj√§lva app-layouten hanteras i DocViewer och den gemensamma wrappern.
        let combinedBody = `<h1>Dokumentation f√∂r ${file}</h1>
`;
        
        // Lokal Set f√∂r att sp√•ra processade noder i denna fil (anv√§nds f√∂r combinedBody)
        // Men vi anv√§nder globalProcessedDocNodes f√∂r att avg√∂ra om dokumentation ska genereras
        const processedDocNodesInFile = new Set<string>();
        
        // PASS 1: Generera subprocesser f√∂rst (l√§gre depth), sedan parent nodes (h√∂gre depth)
        // Detta s√§kerst√§ller att child documentation sparas i generatedChildDocs innan parent Feature Goal genereras
        // Spara dokumentation fr√•n child nodes f√∂r att anv√§nda n√§r parent nodes genereras
        // F√∂r callActivities: anv√§nd subprocessFile som key f√∂r att undvika duplicering av √•terkommande subprocesser
        for (const node of sortedNodesInFile) {
          if (!node.element || !node.bpmnElementId) continue;
          
          // Apply node filter if provided (for selective regeneration based on diff)
          // NOTE: nodeFilter result is also checked in Storage existence check below
          // If nodeFilter says to generate, we override Storage check
          const shouldGenerateByFilter = nodeFilter ? nodeFilter(node) : true;
          if (!shouldGenerateByFilter) {
            continue;
          }
          
          
          // F√∂r callActivities, anv√§nd subprocessFile som key (unik per subprocess-fil)
          // F√∂r tasks/epics, anv√§nd nodeKey (unik per instans)
          const docKey = node.type === 'callActivity' && node.subprocessFile
            ? `subprocess:${node.subprocessFile}` // Unik per subprocess-fil
            : `${node.bpmnFile}::${node.bpmnElementId}`; // Unik per instans f√∂r tasks
          
          // VIKTIGT: F√∂r √•terkommande noder (subprocesser, tasks, epics):
          // - Dokumentation (summary, flowSteps, scenarios, etc.) genereras PER INSTANS
          //   eftersom kontexten kan vara annorlunda f√∂r varje anv√§ndning
          const nodeKey = `${node.bpmnFile}::${node.bpmnElementId}`;
          
          // Kolla om dokumentation redan genererats globalt
          // F√∂r callActivities: kolla b√•de globalProcessedDocNodes och generatedSubprocessFeatureGoals
          // F√∂r tasks/epics: kolla bara globalProcessedDocNodes
          const alreadyProcessedGlobally = globalProcessedDocNodes.has(docKey);
          const subprocessAlreadyGenerated = node.type === 'callActivity' && node.subprocessFile
            ? generatedSubprocessFeatureGoals.has(node.subprocessFile)
            : false;
          
          // VIKTIGT: F√∂r callActivities m√•ste vi ALLTID generera Feature Goal-dokumentation,
          // √§ven om subprocess-filen redan har genererat sin egen Feature Goal.
          // skipDocGeneration anv√§nds bara f√∂r att avg√∂ra om vi ska generera base eller instans-specifik.
          // F√∂r tasks/epics: skipDocGeneration = true betyder att vi hoppar √∂ver generering helt.
          const skipDocGeneration = node.type === 'callActivity'
            ? subprocessAlreadyGenerated // F√∂r callActivities: bara kolla om subprocess redan genererats (vi genererar √§nd√• instans-specifik)
            : (alreadyProcessedGlobally || subprocessAlreadyGenerated); // F√∂r tasks/epics: hoppa √∂ver om redan processad
          
          // (Instance-specific documentation generation continues silently)
          
          // Bygg ett tydligt meddelande med nodtyp och namn
          const nodeTypeLabel = 
            node.type === 'serviceTask' ? 'service tasken' :
            node.type === 'userTask' ? 'user tasken' :
            node.type === 'businessRuleTask' ? 'business rule tasken' :
            node.type === 'callActivity' ? 'call activityn' :
            'noden';
          const nodeName = node.name || node.bpmnElementId || 'Ok√§nd nod';
          const detailMessage = `${nodeTypeLabel}: ${nodeName}${node.type === 'callActivity' && node.subprocessFile ? ` (subprocess: ${node.subprocessFile})` : ''}`;
          
          await reportProgress(
            'docgen:file',
            'Genererar dokumentation',
            detailMessage,
          );

          const docFileKey = getNodeDocFileKey(node.bpmnFile, node.bpmnElementId);
          const nodeContext = buildNodeDocumentationContext(graph, node.id);
          const docLinks = {
            bpmnViewerLink: `#/bpmn/${node.bpmnFile}`,
            dorLink: undefined,
            testLink: undefined, // Testfiler genereras inte l√§ngre i dokumentationssteget
          };

          const dorDodKey = `${node.bpmnFile}:${node.bpmnElementId}`;
          const dorDodForNode = result.dorDod.get(dorDodKey) || [];

          let nodeDocContent: string;
          let lastDocJson: unknown | undefined;

          // VIKTIGT: F√∂r callActivities m√•ste vi ALLTID generera Feature Goal-dokumentation,
          // √§ven om noden redan har processats globalt. Detta s√§kerst√§ller att alla callActivities f√•r dokumentation.
          // F√∂r tasks/epics: hoppa √∂ver om redan processad (f√∂r att undvika dubbelgenerering).
          if (!nodeContext) {
            console.warn(`[bpmnGenerators] ‚ö†Ô∏è No nodeContext found for ${node.bpmnElementId} (${node.type}), skipping`);
            continue;
          }
          
          // F√∂r callActivities: generera alltid Feature Goal, √§ven om alreadyProcessedGlobally √§r true
          // F√∂r tasks/epics: hoppa √∂ver om alreadyProcessedGlobally √§r true (f√∂r att undvika dubbelgenerering)
          if (node.type !== 'callActivity' && alreadyProcessedGlobally) {
            continue; // Hoppa √∂ver tasks/epics som redan processats
          }

          // VIKTIGT: Kolla om dokumentation redan finns i Storage f√∂r leaf nodes (tasks/epics)
          // Om den finns, hoppa √∂ver regenerering f√∂r att spara tid och pengar
          // Men f√∂r callActivities genererar vi alltid (de beh√∂ver uppdateras n√§r subprocesser √§ndras)
          // 
          // Storage-check respekterar:
          // 1. forceRegenerate flag (om true, hoppa √∂ver check)
          // 2. nodeFilter resultat (om nodeFilter s√§ger generera, generera √§ven om fil finns)
          if (node.type !== 'callActivity' && !forceRegenerate) {
            const versionHash = versionHashes.get(node.bpmnFile) || null;
            // Claude-only: Always use 'cloud' provider (maps to 'claude' in storage paths)
            const { modePath } = buildDocStoragePaths(
              docFileKey,
              generationSourceLabel?.includes('slow') ? 'slow' : null,
              'cloud', // Claude-only: always use cloud provider
              node.bpmnFile,
              versionHash
            );
            
            // Check both versioned and non-versioned paths for better reliability
            const versionedExists = versionHash ? await storageFileExists(modePath) : false;
            let docExists = versionedExists;
            
            // If versioned path doesn't exist, check non-versioned path
            if (!versionedExists && versionHash) {
              const { modePath: nonVersionedPath } = buildDocStoragePaths(
                docFileKey,
                generationSourceLabel?.includes('slow') ? 'slow' : null,
                'cloud',
                node.bpmnFile,
                null // No version hash
              );
              docExists = await storageFileExists(nonVersionedPath);
            } else if (!versionHash) {
              docExists = await storageFileExists(modePath);
            }
            
            // If nodeFilter says to generate this node, override Storage check
            // (shouldGenerateByFilter is already computed above)
            if (docExists && !shouldGenerateByFilter) {
              if (import.meta.env.DEV) {
                console.log(`[bpmnGenerators] ‚è≠Ô∏è  Skipping regeneration for ${node.bpmnElementId} (${node.type}) - documentation already exists in Storage: ${modePath}`);
              }
              
              // VIKTIGT: √Ñven om vi hoppar √∂ver regenerering, beh√∂ver vi fortfarande
              // ladda in child documentation f√∂r Feature Goals. F√∂rs√∂k ladda fr√•n Storage.
              const existingDocInfo = await loadChildDocFromStorage(
                node.bpmnFile,
                node.bpmnElementId,
                docFileKey,
                versionHash,
                generationSourceLabel
              );
              
              if (existingDocInfo) {
                // Spara i generatedChildDocs s√• att Feature Goals kan anv√§nda den
                generatedChildDocs.set(docKey, existingDocInfo);
                if (import.meta.env.DEV) {
                  console.log(`[bpmnGenerators] ‚úÖ Loaded existing child doc for ${node.bpmnElementId} from Storage`);
                }
              } else {
                if (import.meta.env.DEV) {
                  console.log(`[bpmnGenerators] ‚ö†Ô∏è  Could not load child doc for ${node.bpmnElementId} from Storage - Feature Goals may have incomplete child documentation`);
                }
              }
              
              // Markera som processad s√• att den inte genereras igen
              processedDocNodesInFile.add(docKey);
              // For callActivities, only add to globalProcessedDocNodes if subprocess not already generated
              // For other node types, always add
              const isCallActivity = (node.type as string) === 'callActivity';
              if (!subprocessAlreadyGenerated || !isCallActivity) {
                globalProcessedDocNodes.add(docKey);
              }
              
              // Forts√§tt till n√§sta nod
              continue;
            }
          }

          if (nodeContext) {
            // Samla dokumentation fr√•n child nodes rekursivt (f√∂r Feature Goals beh√∂ver vi alla descendant nodes)
            // F√∂r callActivities: samla fr√•n alla descendant nodes (inklusive nested subprocesser och leaf nodes)
            // F√∂r tasks/epics: samla bara fr√•n direkta children (de har normalt inga children)
            const childDocsForNode = new Map<string, {
              summary: string;
              flowSteps: string[];
              inputs?: string[];
              outputs?: string[];
              scenarios?: Array<{ id: string; name: string; type: string; outcome: string }>;
            }>();
            
            // Rekursiv funktion f√∂r att samla dokumentation fr√•n alla descendant nodes
            const collectChildDocsRecursively = (currentNode: BpmnProcessNode) => {
              if (currentNode.children && Array.isArray(currentNode.children) && currentNode.children.length > 0) {
                for (const child of currentNode.children) {
                  // F√∂r callActivities, anv√§nd subprocessFile som key f√∂r att hitta dokumentation
                  // √§ven om child √§r en annan instans av samma subprocess
                  const childDocKey = child.type === 'callActivity' && child.subprocessFile
                    ? `subprocess:${child.subprocessFile}`
                    : `${child.bpmnFile}::${child.bpmnElementId}`;
                  
                  const childDoc = generatedChildDocs.get(childDocKey);
                  if (childDoc) {
                    childDocsForNode.set(child.id, childDoc);
                  }
                  
                  // Rekursivt samla fr√•n nested children (f√∂r nested subprocesser)
                  if (child.children && Array.isArray(child.children) && child.children.length > 0) {
                    collectChildDocsRecursively(child);
                  }
                }
              }
            };
            
            // F√∂r callActivities: samla rekursivt fr√•n alla descendant nodes
            // Detta s√§kerst√§ller att vi f√•r dokumentation fr√•n alla leaf nodes (tasks/epics) i subprocessen
            if (node.type === 'callActivity') {
              collectChildDocsRecursively(node);
            } else {
              // F√∂r tasks/epics: samla bara fr√•n direkta children (de har normalt inga children)
              if (node.children && node.children.length > 0) {
                for (const child of node.children) {
                  const childDocKey = child.type === 'callActivity' && child.subprocessFile
                    ? `subprocess:${child.subprocessFile}`
                    : `${child.bpmnFile}::${child.bpmnElementId}`;
                  
                  const childDoc = generatedChildDocs.get(childDocKey);
                  if (childDoc) {
                    childDocsForNode.set(child.id, childDoc);
                  }
                }
              }
            }
            
            // Convert childDocsForNode to ChildNodeDocumentation format
            const convertedChildDocs = childDocsForNode.size > 0 
              ? new Map<string, ChildNodeDocumentation>() 
              : undefined;
            if (convertedChildDocs && node.children) {
              for (const child of node.children) {
                const childDoc = childDocsForNode.get(child.id);
                if (childDoc) {
                  convertedChildDocs.set(child.id, {
                    id: child.bpmnElementId || child.id,
                    name: child.name || child.bpmnElementId || child.id,
                    type: child.type,
                    summary: childDoc.summary,
                    flowSteps: childDoc.flowSteps,
                    inputs: childDoc.inputs,
                    outputs: childDoc.outputs,
                  });
                }
              }
            }
            
            if (node.type === 'callActivity') {
              // VIKTIGT: Validera att detta faktiskt √§r en CallActivity (inte en task eller subProcess)
              // F√∂rhindra att tasks eller subProcess genereras som feature goals
              if (node.type !== 'callActivity') {
                if (import.meta.env.DEV) {
                  console.warn(
                    `[bpmnGenerators] ‚ö†Ô∏è Skipping Feature Goal generation for ${node.bpmnElementId} - ` +
                    `node is not a CallActivity (type: ${node.type})`
                  );
                }
                continue;
              }
              
              // VIKTIGT: F√∂rhindra att subProcess (event-triggered subprocesses) genereras som Feature Goals
              // subProcess √§r INTE callActivity - de √§r embedded subprocesses, inte separate files
              // Om subprocessFile saknas, √§r det troligen en subProcess, inte en callActivity
              if (!node.subprocessFile) {
                console.warn(
                  `[bpmnGenerators] ‚ö†Ô∏è KRITISKT: Skipping Feature Goal generation for ${node.bpmnElementId} ` +
                  `(no subprocessFile - likely a subProcess, not a callActivity)`
                );
                continue;
              }
              
              // VIKTIGT: Verifiera att subprocess-filen faktiskt finns innan vi genererar Feature Goal
              // Om subprocess-filen saknas, hoppa √∂ver (borde redan filtrerats bort i nodesToGenerate,
              // men dubbelkolla h√§r ocks√• f√∂r s√§kerhets skull)
              if (node.missingDefinition) {
                if (import.meta.env.DEV) {
                  console.warn(
                    `[bpmnGenerators] ‚ö†Ô∏è Skipping Feature Goal generation for ${node.bpmnElementId} ` +
                    `(subprocess file ${node.subprocessFile || 'unknown'} is missing)`
                  );
                }
                continue;
              }
              
              if (node.subprocessFile && !existingBpmnFiles.includes(node.subprocessFile)) {
                if (import.meta.env.DEV) {
                  console.warn(
                    `[bpmnGenerators] ‚ö†Ô∏è Skipping Feature Goal generation for ${node.bpmnElementId} ` +
                    `(subprocess file ${node.subprocessFile} not in existingBpmnFiles)`
                  );
                }
                continue;
              }
              
              // STRATEGI: F√∂r callActivities som pekar p√• subprocesser:
              // - Om subprocess-filen redan genererat Feature Goal ‚Üí skapa instans-specifik dokumentation
              //   med parent-fil i namnet (hierarkisk naming)
              // - Om subprocess-filen inte genererat √§n ‚Üí generera base Feature Goal och spara
              //   (subprocess-filen kommer senare anv√§nda denna base doc)
              
              // VIKTIGT: F√∂r callActivities m√•ste vi ALLTID generera Feature Goal-dokumentation,
              // √§ven om subprocess-filen redan har genererat sin egen Feature Goal.
              // Detta s√§kerst√§ller att alla callActivity-instanser f√•r dokumentation.
              // skipDocGeneration f√∂r callActivities betyder bara att subprocess redan genererats,
              // men vi genererar √§nd√• instans-specifik dokumentation.
              
              // F√∂r callActivities: generera alltid Feature Goal (skipDocGeneration anv√§nds bara f√∂r att avg√∂ra base vs instans-specifik)
              if (skipDocGeneration && node.subprocessFile) {
                // √Öterkommande callActivity: subprocess-filen har redan genererat base Feature Goal
                // Generera instans-specifik dokumentation med parent-kontext
                const existingDoc = generatedChildDocs.get(docKey);
                if (existingDoc) {
                  // Generera instans-specifik dokumentation med LLM
                  // Detta skapar en separat Feature Goal-sida med parent-fil i namnet
                  nodeDocContent = await renderDocWithLlm(
                    'feature',
                    nodeContext,
                    docLinks,
                    useLlm,
                    llmProvider,
                    async (provider, fallbackUsed, docJson) => {
                      if (fallbackUsed) {
                        llmFallbackUsed = true;
                        llmFinalProvider = provider;
                      }
                      if (docJson) {
                        lastDocJson = docJson;
                        // Spara instans-specifik dokumentation med instans-specifik key f√∂r framtida referens
                        // Key: `${node.bpmnFile}::${node.bpmnElementId}` (unik per callActivity-instans)
                        const instanceDocKey = nodeKey;
                        const docInfo = extractDocInfoFromJson(docJson);
                        if (docInfo && !generatedChildDocs.has(instanceDocKey)) {
                          generatedChildDocs.set(instanceDocKey, docInfo);
                        }
                      }
                    },
                    convertedChildDocs,
                    undefined, // structuralInfo
                    checkCancellation,
                    abortSignal,
                  );
                } else {
                  // Ingen dokumentation att h√§mta - detta kan h√§nda om subprocess-filen inte √§r med i analyzedFiles
                  // Generera Feature Goal √§nd√• med LLM (inte bara fallback)
                  nodeDocContent = await renderDocWithLlm(
                    'feature',
                    nodeContext,
                    docLinks,
                    useLlm,
                    llmProvider,
                    async (provider, fallbackUsed, docJson) => {
                      if (fallbackUsed) {
                        llmFallbackUsed = true;
                        llmFinalProvider = provider;
                      }
                      if (docJson) {
                        lastDocJson = docJson;
                        // Spara dokumentation f√∂r framtida referens
                        const docInfo = extractDocInfoFromJson(docJson);
                        if (docInfo) {
                          const subprocessDocKey = `subprocess:${node.subprocessFile}`;
                          if (!generatedChildDocs.has(subprocessDocKey)) {
                            generatedChildDocs.set(subprocessDocKey, docInfo);
                            generatedSubprocessFeatureGoals.add(node.subprocessFile);
                          }
                        }
                      }
                    },
                    convertedChildDocs,
                    undefined, // structuralInfo (not available in this context)
                    checkCancellation,
                    abortSignal,
                  );
                }
              } else {
                
                // F√∂rsta g√•ngen subprocessen genereras - generera b√•de dokumentation och testscenarion
                nodeDocContent = await renderDocWithLlm(
                  'feature',
                  nodeContext,
                  docLinks,
                  useLlm,
                  llmProvider,
                  async (provider, fallbackUsed, docJson) => {
                    if (fallbackUsed) {
                      llmFallbackUsed = true;
                      llmFinalProvider = provider;
                    }
                    const scenarioProvider = mapProviderToScenarioProvider(
                      provider,
                      fallbackUsed,
                    );
                    if (docJson) {
                      lastDocJson = docJson;
                      
                      // F√∂r callActivities: spara dokumentation och markera subprocessen som genererad
                      if (node.type === 'callActivity' && node.subprocessFile) {
                        const docInfo = extractDocInfoFromJson(docJson);
                        if (docInfo) {
                          const subprocessDocKey = `subprocess:${node.subprocessFile}`;
                          // Spara bara om det inte redan finns (f√∂rsta g√•ngen subprocessen genereras)
                          if (!generatedChildDocs.has(subprocessDocKey)) {
                            generatedChildDocs.set(subprocessDocKey, docInfo);
                            // Markera att Feature Goal-dokumentation har genererats f√∂r denna subprocess
                            generatedSubprocessFeatureGoals.add(node.subprocessFile);
                          }
                        }
                      }
                    }
                    // OBS: Testscenarion (scenarios) genereras inte l√§ngre i dokumentationssteget.
                    // Testinformation genereras i ett separat steg och ska inte sparas h√§r.
                  },
                  childDocsForNode.size > 0 ? childDocsForNode : undefined,
                  undefined, // structuralInfo (not available in this context)
                  checkCancellation,
                  abortSignal,
                );
              }
              // Skapa Feature Goal-sida f√∂r callActivity
              // VIKTIGT: F√∂r call activities anv√§nder vi ALLTID hierarchical naming (med parent)
              // eftersom filen alltid sparas under parent-filens version hash.
              // Subprocess-filen kommer senare generera sin egen Feature Goal-sida (utan parent)
              // n√§r subprocess-filen genereras separat.
              const bpmnFileForFeatureGoal = node.type === 'callActivity' && node.subprocessFile
                ? node.subprocessFile
                : node.bpmnFile;
              
              // Use hierarchical naming: parent BPMN file (where call activity is defined) + elementId
              // This matches Jira naming (e.g., "Application - Internal data gathering")
              // VIKTIGT: F√∂r call activities anv√§nder vi ALLTID parent f√∂r hierarchical naming,
              // eftersom filen sparas under parent-filens version hash i storage.
              const parentBpmnFile = node.type === 'callActivity' ? node.bpmnFile : undefined;
              const featureDocPath = getFeatureGoalDocFileKey(
                bpmnFileForFeatureGoal,
                node.bpmnElementId,
                undefined, // no version suffix
                parentBpmnFile, // ALLTID anv√§nd parent f√∂r call activities (hierarchical naming)
              );
              
              // Skapa Feature Goal-sida endast om den inte redan finns (f√∂rhindra dubbelgenerering)
              if (!result.docs.has(featureDocPath)) {
                result.docs.set(
                  featureDocPath,
                  insertGenerationMeta(nodeDocContent, generationSourceLabel),
                );
              }
              // L√§gg till diagnostiksektion om subprocess-matchen inte √§r bekr√§ftad
              if (
                node.subprocessMatchStatus &&
                node.subprocessMatchStatus !== 'matched'
              ) {
                const diag = buildMatchWarning(node);
                const section = `<section><h2>Subprocess-diagnostik</h2>${diag}</section>`;
                if (nodeDocContent.includes('</body>')) {
                  nodeDocContent = nodeDocContent.replace(
                    '</body>',
                    `${section}</body>`,
                  );
                } else {
                  nodeDocContent += section;
                }
              }
            } else if (node.type === 'businessRuleTask') {
              nodeDocContent = await renderDocWithLlm(
                'businessRule',
                nodeContext,
                docLinks,
                useLlm,
                llmProvider,
                async (provider, fallbackUsed, docJson) => {
                  if (fallbackUsed) {
                    llmFallbackUsed = true;
                    llmFinalProvider = provider;
                  }
                  const scenarioProvider = mapProviderToScenarioProvider(
                    provider,
                    fallbackUsed,
                  );
                  if (docJson) {
                    lastDocJson = docJson;
                    
                    // Spara child node dokumentation f√∂r att anv√§nda i parent node prompts
                    // F√∂r callActivities: anv√§nd subprocessFile som key (f√∂r √•terkommande subprocesser)
                    // F√∂r tasks/epics: anv√§nd node.id som key
                    // VIKTIGT: F√∂r √•terkommande noder sparar vi bara f√∂rsta g√•ngen
                    // (f√∂r att anv√§nda i parent node prompts), men genererar dokumentation per instans
                    if (docJson && typeof docJson === 'object') {
                      const childDocKey = node.type === 'callActivity' && node.subprocessFile
                        ? `subprocess:${node.subprocessFile}`
                        : node.id;
                      
                      // Spara bara om det inte redan finns (f√∂rsta g√•ngen noden genereras)
                      if (!generatedChildDocs.has(childDocKey)) {
                        const childDocInfo = {
                          summary: (docJson as any).summary || '',
                          flowSteps: Array.isArray((docJson as any).decisionLogic) ? (docJson as any).decisionLogic : [],
                          inputs: Array.isArray((docJson as any).inputs) ? (docJson as any).inputs : [],
                          outputs: Array.isArray((docJson as any).outputs) ? (docJson as any).outputs : [],
                          scenarios: Array.isArray((docJson as any).scenarios) ? (docJson as any).scenarios : [],
                        };
                        generatedChildDocs.set(childDocKey, childDocInfo);
                      }
                    }
                  }
                  // OBS: Testscenarion (scenarios) genereras inte l√§ngre i dokumentationssteget.
                  // Testinformation genereras i ett separat steg och ska inte sparas h√§r.
                },
                undefined, // childrenDocumentation (not applicable for businessRule/epic)
                undefined, // structuralInfo (not applicable for businessRule)
                checkCancellation,
                abortSignal,
              );
              if (!(docLinks as any).dmnLink) {
                nodeDocContent +=
                  '\n<p>Ingen DMN-l√§nk konfigurerad √§nnu ‚Äì l√§gg till beslutstabell n√§r den finns.</p>';
              }
            } else {
              nodeDocContent = await renderDocWithLlm(
                'epic',
                nodeContext,
                docLinks,
                useLlm,
                llmProvider,
                async (provider, fallbackUsed, docJson) => {
                  if (fallbackUsed) {
                    llmFallbackUsed = true;
                    llmFinalProvider = provider;
                  }
                  const scenarioProvider = mapProviderToScenarioProvider(
                    provider,
                    fallbackUsed,
                  );
                  if (docJson) {
                    lastDocJson = docJson;
                    
                    // Spara child node dokumentation f√∂r att anv√§nda i parent node prompts
                    // F√∂r callActivities: anv√§nd subprocessFile som key (f√∂r √•terkommande subprocesser)
                    // F√∂r tasks/epics: anv√§nd node.id som key
                    // VIKTIGT: F√∂r √•terkommande subprocesser sparar vi bara f√∂rsta g√•ngen
                    // (f√∂r att anv√§nda i parent node prompts), men genererar dokumentation per instans
                    if (docJson && typeof docJson === 'object') {
                      const childDocKey = node.type === 'callActivity' && node.subprocessFile
                        ? `subprocess:${node.subprocessFile}`
                        : node.id;
                      
                      // Spara bara om det inte redan finns (f√∂rsta g√•ngen subprocessen genereras)
                      if (!generatedChildDocs.has(childDocKey)) {
                        const childDocInfo = {
                          summary: (docJson as any).summary || '',
                          flowSteps: Array.isArray((docJson as any).flowSteps) ? (docJson as any).flowSteps : [],
                          inputs: Array.isArray((docJson as any).inputs) ? (docJson as any).inputs : [],
                          outputs: Array.isArray((docJson as any).outputs) ? (docJson as any).outputs : [],
                          scenarios: Array.isArray((docJson as any).scenarios) ? (docJson as any).scenarios : [],
                        };
                        generatedChildDocs.set(childDocKey, childDocInfo);
                      }
                    }
                  }
                  // OBS: Testscenarion (scenarios) genereras inte l√§ngre i dokumentationssteget.
                  // Testinformation genereras i ett separat steg och ska inte sparas h√§r.
                },
                undefined, // childrenDocumentation (not applicable for epic)
                undefined, // structuralInfo (not applicable for epic)
                checkCancellation,
                abortSignal,
              );
            }
          } else {
            nodeDocContent = generateDocumentationHTML(node.element, undefined, undefined, dorDodForNode);
          }

          // VIKTIGT: callActivities har redan lagts till med Feature Goal-path (rad 2006-2009)
          // S√• vi ska INTE l√§gga till dem igen med Epic-path h√§r
          // Endast userTasks, serviceTasks och businessRuleTasks ska l√§ggas till h√§r
          if (node.type !== 'callActivity') {

            result.docs.set(
              docFileKey,
              insertGenerationMeta(nodeDocContent, generationSourceLabel),
            );
          }

          // === TESTGENERERING HAR FLYTTATS TILL SEPARAT STEG ===
          // Testfiler och testscenarion genereras inte l√§ngre i dokumentationssteget.
          // Scenarion fr√•n dokumentationen sparas fortfarande i node_planned_scenarios
          // (se renderDocWithLlm callback ovan) eftersom de √§r del av dokumentationen.

          hierarchicalNodeArtifacts.push({
            bpmnFile: node.bpmnFile,
            elementId: node.bpmnElementId,
            elementName: node.name || node.bpmnElementId,
            docFileName: docFileKey,
            testFileName: undefined, // Testfiler genereras inte l√§ngre h√§r
          });
          // Markera som processad b√•de lokalt (f√∂r combinedBody) och globalt (f√∂r dubbelgenerering)
          processedDocNodesInFile.add(docKey);
          // F√∂r callActivities: markera med docKey (subprocess:file) f√∂r att undvika dubbelgenerering av base doc
          // F√∂r tasks/epics: markera med docKey (file::elementId) f√∂r att undvika dubbelgenerering
          // Men vi till√•ter fortfarande instans-specifik dokumentation f√∂r √•terkommande noder
          if (!subprocessAlreadyGenerated || node.type !== 'callActivity') {
            globalProcessedDocNodes.add(docKey);
          }

          const bodyMatch = nodeDocContent.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
          if (bodyMatch) {
            combinedBody += `<div class="node-section">
  <span class="node-type">${node.type}</span>
  <h2>${node.name || node.bpmnElementId}</h2>
  ${bodyMatch[1]}
</div>
`;
          }
        }
        
        // Generera combined file-level documentation ENDAST f√∂r root-processer (inte f√∂r subprocesser)
        // Subprocesser har redan Feature Goal-dokumentation som t√§cker processen
        // Root-processer beh√∂ver combined doc som en samlad √∂versikt √∂ver alla noder
        // En fil √§r en root-fil om:
        // 1. Den √§r den faktiska root-filen i hierarkin (bpmnFileName === file OCH isRootFileGeneration = true), ELLER
        // 2. Den √§r root-processen enligt bpmn-map.json (orchestration.root_process)
        //    Om bpmn-map inte kan laddas, anv√§nd fallback: filen √§r root om den INTE √§r en subprocess-fil
        const fileBaseNameForRoot = file.replace('.bpmn', '');
        const isRootProcessFromMapForRoot = rootProcessId && (fileBaseNameForRoot === rootProcessId || file === `${rootProcessId}.bpmn`);
        const hasCallActivityPointingToFileForRoot = Array.from(testableNodes.values()).some(
          node => node.type === 'callActivity' && node.subprocessFile === file
        );
        const processNodeForFileForRoot = Array.from(graph.allNodes.values()).find(
          node => node.type === 'process' && node.bpmnFile === file
        );
        const isSubprocessFileForRoot = (hasCallActivityPointingToFileForRoot || !!processNodeForFileForRoot) && !isRootProcessFromMapForRoot;
        const isRootFile = isRootProcessFromMapForRoot || (isRootFileGeneration && file === bpmnFileName) || (!isSubprocessFileForRoot && !rootProcessId);
        
        if (isRootFile && combinedBody.trim().length > 0) {
          const wrappedCombined = insertGenerationMeta(
            wrapLlmContentAsDocument(combinedBody, `Dokumentation - ${file}`),
            generationSourceLabel,
          );
          result.docs.set(docFileName, wrappedCombined);
        }
      } else {
        // Om inga noder hittades, skapa en tom dokumentationsfil ENDAST f√∂r root-processer
        // Subprocesser ska INTE f√• tom dokumentation (de har redan Feature Goal)
        const fileBaseNameForEmpty = file.replace('.bpmn', '');
        const isRootProcessFromMapForEmpty = rootProcessId && (fileBaseNameForEmpty === rootProcessId || file === `${rootProcessId}.bpmn`);
        const processNodeForFileForEmpty = Array.from(graph.allNodes.values()).find(
          node => node.type === 'process' && node.bpmnFile === file
        );
        const hasCallActivityPointingToFileForEmpty = Array.from(testableNodes.values()).some(
          node => node.type === 'callActivity' && node.subprocessFile === file
        );
        const isSubprocessFileForEmpty = (hasCallActivityPointingToFileForEmpty || !!processNodeForFileForEmpty) && !isRootProcessFromMapForEmpty;
        const isRootFileForEmpty = isRootProcessFromMapForEmpty || (isRootFileGeneration && file === bpmnFileName) || (!isSubprocessFileForEmpty && !rootProcessId);
        
        if (isRootFileForEmpty) {
          // Skapa tom dokumentation endast f√∂r root-processer
          const emptyDoc = insertGenerationMeta(
            wrapLlmContentAsDocument(
              `<h1>Dokumentation f√∂r ${file}</h1><p>Inga genererbara noder hittades i denna fil.</p>`,
              `Dokumentation - ${file}`
            ),
            generationSourceLabel,
          );
          result.docs.set(docFileName, emptyDoc);
          console.warn(`[bpmnGenerators] ‚ö†Ô∏è No nodes found for ${file}, created empty documentation file`);
        }
      }
      
      // KRITISKT: Feature Goal-generering f√∂r subprocess-filer m√•ste k√∂ras √§ven om nodesInFile.length === 0
      // (t.ex. filer som bara har en process-nod men inga tasks/callActivities)
      // Detta s√§kerst√§ller att alla subprocess-filer f√•r Feature Goal-dokumentation
      // VIKTIGT: Detta m√•ste k√∂ras UTANF√ñR if (nodesInFile.length > 0)-blocket
      const hasCallActivityPointingToFileForSubprocess = Array.from(testableNodes.values()).some(
        node => node.type === 'callActivity' && node.subprocessFile === file
      );
      const processNodeForFileForSubprocess = Array.from(graph.allNodes.values()).find(
        node => node.type === 'process' && node.bpmnFile === file
      );
      const fileBaseNameForSubprocess = file.replace('.bpmn', '');
      const isRootProcessFromMapForSubprocess = rootProcessId && (fileBaseNameForSubprocess === rootProcessId || file === `${rootProcessId}.bpmn`);
      const isSubprocessFileForSubprocess = (hasCallActivityPointingToFileForSubprocess || !!processNodeForFileForSubprocess) && !isRootProcessFromMapForSubprocess;
      
      // Generera Feature Goal f√∂r subprocess-filer √§ven om nodesInFile.length === 0
      if (isSubprocessFileForSubprocess && processNodeForFileForSubprocess && processNodeForFileForSubprocess.type === 'process') {
        const subprocessDocKey = `subprocess:${file}`;
        // VIKTIGT: F√∂r subprocess process nodes, anv√§nd filens base name (utan .bpmn) som elementId
        // eftersom process-nodens bpmnElementId kan vara processId (t.ex. "mortgage-se-appeal.bpmn#process")
        // men vi vill ha filens base name (t.ex. "mortgage-se-appeal") f√∂r Feature Goal-filnamnet
        const fileBaseName = file.replace('.bpmn', '');
        const subprocessFeatureDocPath = getFeatureGoalDocFileKey(
          file,
          fileBaseName, // Anv√§nd filens base name ist√§llet f√∂r processNodeForFileForSubprocess.bpmnElementId
          undefined,
          undefined,
        );
        const featureGoalPageExists = result.docs.has(subprocessFeatureDocPath);
        
        if (!featureGoalPageExists) {
          // Samla child docs fr√•n processNodeForFileForSubprocess.children (om de finns)
          const childDocsForSubprocess = new Map<string, {
            summary: string;
            flowSteps: string[];
            inputs?: string[];
            outputs?: string[];
            scenarios?: Array<{ id: string; name: string; type: string; outcome: string }>;
          }>();
          
          const collectChildDocsRecursively = (node: BpmnProcessNode) => {
            for (const child of node.children) {
              const childDocKey = child.type === 'callActivity' && child.subprocessFile
                ? `subprocess:${child.subprocessFile}`
                : `${child.bpmnFile}::${child.bpmnElementId}`;
              
              const childDoc = generatedChildDocs.get(childDocKey);
              if (childDoc) {
                childDocsForSubprocess.set(child.id, childDoc);
              }
              
              if (child.children && child.children.length > 0) {
                collectChildDocsRecursively(child);
              }
            }
          };
          
          // Anv√§nd processNodeForFileForSubprocess.children direkt (filen har inga tasks/callActivities)
          if (processNodeForFileForSubprocess.children && processNodeForFileForSubprocess.children.length > 0) {
            collectChildDocsRecursively(processNodeForFileForSubprocess);
          }
          
          const subprocessContext = buildNodeDocumentationContext(graph, processNodeForFileForSubprocess.id);
          
          if (subprocessContext) {
            await reportProgress(
              'docgen:file',
              'Genererar Feature Goal f√∂r subprocess',
              `${file} (subprocess root)`,
            );
            
            const subprocessDocLinks = {
              bpmnViewerLink: `#/bpmn/${file}`,
              dorLink: undefined,
              testLink: undefined,
            };
            
            const subprocessDocContent = await renderDocWithLlm(
              'feature',
              subprocessContext,
              subprocessDocLinks,
              useLlm,
              llmProvider,
              async (provider, fallbackUsed, docJson) => {
                if (fallbackUsed) {
                  llmFallbackUsed = true;
                  llmFinalProvider = provider;
                }
                if (docJson) {
                  const docInfo = extractDocInfoFromJson(docJson);
                  if (docInfo) {
                    generatedChildDocs.set(subprocessDocKey, docInfo);
                    generatedSubprocessFeatureGoals.add(file);
                  }
                }
              },
              childDocsForSubprocess.size > 0 ? childDocsForSubprocess : undefined,
              undefined, // structuralInfo (not available in this context)
              checkCancellation,
              abortSignal,
            );
            
            result.docs.set(
              subprocessFeatureDocPath,
              insertGenerationMeta(subprocessDocContent, generationSourceLabel),
            );
            
            console.log(`[bpmnGenerators] ‚úÖ Feature Goal generated for subprocess ${file} (no tasks/callActivities):`, {
              subprocessFeatureDocPath,
              contentLength: subprocessDocContent.length,
            });
          } else {
            console.error(`[bpmnGenerators] ‚ùå KRITISKT: Feature Goal NOT generated for ${file} - missing subprocessContext (process node exists: ${processNodeForFileForSubprocess.id})`);
          }
        }
      }
    }
    await reportProgress('docgen:complete', 'Dokumentation klara');

    if (result.metadata) {
      result.metadata.llmFallbackUsed = llmFallbackUsed;
      result.metadata.llmFinalProvider = llmFinalProvider;
    }

    return result;
  } catch (error) {
    if (!useHierarchy) {
      console.warn(
        '[generateAllFromBpmnWithGraph] Hierarchical pipeline failed, falling back to legacy generator',
        error,
      );
      const fileUrl = `/bpmn/${bpmnFileName}`;
      const parseResult = await parseBpmnFile(fileUrl);
      
      return generateAllFromBpmn(
        parseResult.elements,
        parseResult.subprocesses,
        existingBpmnFiles,
        existingDmnFiles,
        bpmnFileName,
        useLlm,
        generationSourceLabel,
        llmProvider,
      );
    }
    throw error;
  }
}

export async function generateAllFromBpmn(
  elements: BpmnElement[],
  subprocesses: BpmnSubprocess[],
  existingBpmnFiles: string[],
  existingDmnFiles: string[] = [],
  bpmnFileName?: string,
  useLlm: boolean = true,
  generationSourceLabel?: string,
  llmProvider?: LlmProvider
): Promise<GenerationResult> {
  const result: GenerationResult = {
    tests: new Map(),
    docs: new Map(),
    dorDod: new Map(),
    subprocessMappings: new Map(),
  };
  const docSource = generationSourceLabel || (useLlm ? 'llm' : 'local');
  const nodeArtifacts: NodeArtifactEntry[] = [];
  result.nodeArtifacts = nodeArtifacts;

  // Samla dokumentation f√∂r alla element i filen
  let combinedDoc = '';
  if (bpmnFileName) {
    combinedDoc = `<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dokumentation - ${bpmnFileName}</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 16px; background: #ffffff; }
    h1 { font-size: 1.5rem; margin: 0 0 24px; border-bottom: 1px solid #e2e8f0; padding-bottom: 8px; }
    h2 { color: #1e40af; margin-top: 24px; font-size: 1.1rem; }
    .node-section { border-left: 3px solid #dbeafe; padding-left: 16px; margin: 16px 0; }
    .node-type { display: inline-block; background: #dbeafe; color: #1e40af; padding: 4px 10px; border-radius: 4px; font-size: 0.85rem; }
  </style>
</head>
<body>
  <h1>Dokumentation f√∂r ${bpmnFileName}</h1>
`;
  }

  // Generate for each element
  for (const element of elements) {
    let docContent: string | null = null;
    let nodeTestFileKey: string | null = null;
    const nodeType = element.type.replace('bpmn:', '') as 'ServiceTask' | 'UserTask' | 'BusinessRuleTask' | 'CallActivity' | string;
    
    // Skip process definitions and labels
    if (nodeType === 'Process' || nodeType === 'Collaboration' || element.type === 'label') {
      continue;
    }

    // === TESTGENERERING HAR FLYTTATS TILL SEPARAT STEG ===
    // Testfiler och testscenarion genereras inte l√§ngre i dokumentationssteget.
    // Anv√§nd separat testgenereringsfunktion ist√§llet.
    nodeTestFileKey = undefined;
      
    // Generate DoR/DoD criteria for individual elements
    // Use hyphen for normalization (consistent with subprocess IDs)
    const normalizedName = (element.name || element.id)
      .toLowerCase()
      .trim()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '');
      
    if (nodeType === 'ServiceTask' || nodeType === 'UserTask' || nodeType === 'BusinessRuleTask' || nodeType === 'CallActivity') {
      const criteria = generateDorDodForNodeType(
        nodeType as 'ServiceTask' | 'UserTask' | 'BusinessRuleTask' | 'CallActivity',
        normalizedName
      );
      
      // Add node metadata to each criterion
      const enrichedCriteria = criteria.map(c => ({
        ...c,
        node_type: nodeType,
        bpmn_element_id: element.id,
        bpmn_file: bpmnFileName
      }));
      
      result.dorDod.set(normalizedName, enrichedCriteria);
    }

    // Generate documentation with subprocess/DMN info
    let subprocessFile: string | undefined;
    let subprocessSummary: SubprocessSummary | undefined;
    
    if (nodeType === 'CallActivity') {
      subprocessFile = undefined; // Legacy l√§ge utan hierarki g√∂r ingen deterministisk matchning
    } else if (nodeType === 'BusinessRuleTask') {
      // Match DMN file for BusinessRuleTask
      const { matchDmnFile } = await import('./dmnParser');
      subprocessFile = matchDmnFile(element.name || element.id, existingDmnFiles);
      
      // Parse DMN if file exists
      if (subprocessFile && existingDmnFiles.includes(subprocessFile)) {
        subprocessSummary = await parseDmnSummary(subprocessFile) || undefined;
        result.subprocessMappings.set(element.id, subprocessFile);
      }
    }
    
    if (['UserTask', 'ServiceTask', 'BusinessRuleTask', 'CallActivity'].includes(nodeType)) {
      docContent = generateDocumentationHTML(element, subprocessFile, subprocessSummary);
      const docFileKey = bpmnFileName
        ? getNodeDocFileKey(bpmnFileName, element.id)
        : `${element.id}.html`;
      result.docs.set(docFileKey, insertGenerationMeta(docContent, docSource));
      
      nodeArtifacts.push({
        bpmnFile: bpmnFileName || '',
        elementId: element.id,
        elementName: element.name || element.id,
        docFileName: docFileKey,
        testFileName: nodeTestFileKey || undefined,
      });
    }

    if (bpmnFileName) {
      if (!docContent) {
        docContent = generateDocumentationHTML(element, subprocessFile, subprocessSummary);
      }
      const bodyMatch = docContent.match(/<body>([\s\S]*)<\/body>/);
      if (bodyMatch) {
        combinedDoc += `<div class="node-section">
  <span class="node-type">${nodeType}</span>
  <h2>${element.name || element.id}</h2>
  ${bodyMatch[1]}
</div>
`;
      }
    }
  }

  // Avsluta och spara kombinerad dokumentation
  if (bpmnFileName && combinedDoc) {
    combinedDoc += `
</body>
</html>`;
    const docFileName = bpmnFileName.replace('.bpmn', '.html');
    result.docs.set(docFileName, insertGenerationMeta(combinedDoc, docSource));
  }

  // Generate DoR/DoD for subprocesses (legacy support)
  subprocesses.forEach(subprocess => {
    const criteria = generateDorDodCriteria(subprocess.name, 'CallActivity');
    // Use hyphen for normalization
    const normalizedName = subprocess.name
      .toLowerCase()
      .trim()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '');
    
    // Only add if not already added from elements loop
    if (!result.dorDod.has(normalizedName)) {
      result.dorDod.set(normalizedName, criteria);
    }
  });

  return result;
}

/**
 * H√§mta design-scenarion fr√•n testMapping och mappa dem till formatet
 * som anv√§nds av generateTestSkeleton. Anv√§nds enbart f√∂r lokal generering
 * (useLlm = false) s√• vi inte √§ndrar LLM-beteendet.
 */
function getDesignScenariosForElement(
  element: BpmnElement,
): { name: string; description: string; expectedResult?: string; steps?: string[] }[] | undefined {
  const mapping = testMapping[element.id];
  if (!mapping || !mapping.scenarios || mapping.scenarios.length === 0) {
    return undefined;
  }

  const scenarios = mapping.scenarios.map((s: TestScenario) => ({
    name: s.name,
    description: s.description,
    expectedResult: s.description,
    // steps l√§mnas tomma s√• generateTestSkeleton genererar generiska TODO-kommentarer
  }));

  return scenarios.length ? scenarios : undefined;
}

// ============= PROCESS TREE BASED GENERATORS =============
// These functions use ProcessTreeNode directly (from Graph ‚Üí Tree pipeline)
// instead of the old meta/hierarchy-based approach

/**
 * Generate hierarchical test file from ProcessTree
 * Uses ProcessTreeNode directly instead of BpmnHierarchyNode
 */
export function generateHierarchicalTestFileFromTree(
  root: ProcessTreeNode,
  bpmnFile: string
): string {
  const contextRoot = root.label;
  let testTemplate = `import { test, expect } from '@playwright/test';

/**
 * Hierarchical Tests for: ${contextRoot}
 * BPMN File: ${bpmnFile}
 * 
 * This test file mirrors the BPMN process hierarchy:
 * - Root: ${contextRoot} (Initiative/Process)
 * - Feature Goals: CallActivities (nested describe blocks)
 * - Epics: UserTask/ServiceTask/BusinessRuleTask (test cases)
 * 
 * Each test includes metadata annotations for filtering:
 * - @initiative:${contextRoot.toLowerCase().replace(/\s+/g, '-')}
 * - @feature:<feature-goal-path>
 * - @epic:<full-hierarchical-path>
 * - @bpmn:<element-id>
 * 
 * Architecture: Tests, documentation, and dashboard all use the
 * same ProcessTree model to ensure consistency across the application.
 */

test.describe('${contextRoot}', () => {
`;

  // Generate nested structure from ProcessTree
  root.children.forEach(child => {
    testTemplate += generateNodeTestsFromProcessTree(child, contextRoot, 1);
  });

  testTemplate += '});\n';
  return testTemplate;
}

/**
 * Recursively generate test structure from ProcessTreeNode
 */
function generateNodeTestsFromProcessTree(
  node: ProcessTreeNode,
  initiative: string,
  indentLevel: number
): string {
  const indent = '  '.repeat(indentLevel);
  let result = '';

  if (node.type === 'process') {
    // Process node - generate children only
    if (node.children && Array.isArray(node.children)) {
      node.children.forEach(child => {
        result += generateNodeTestsFromProcessTree(child, initiative, indentLevel);
      });
    }
  } else if (node.type === 'callActivity') {
    // Feature goal - create describe block
    const orderPrefix = typeof node.orderIndex === 'number' ? `[#${node.orderIndex}] ` : '';
    result += `\n${indent}test.describe('${orderPrefix}${node.label}', () => {\n`;

    // Generate tests for children
    if (node.children && Array.isArray(node.children)) {
      node.children.forEach(child => {
        result += generateNodeTestsFromProcessTree(child, initiative, indentLevel + 1);
      });
    }
    
    result += `${indent}});\n`;
  } else if (node.type === 'userTask' || node.type === 'serviceTask' || node.type === 'businessRuleTask') {
    // Leaf node - generate test
    const orderPrefix = typeof node.orderIndex === 'number' ? `[#${node.orderIndex}] ` : '';
    const scenarioPath = node.scenarioPath?.join('/') ?? 'main';
    const bpmnId = node.bpmnElementId || node.id;
    
    result += `\n${indent}test('${orderPrefix}${node.label}', async ({ page }) => {\n`;
    result += `${indent}  // TODO: Implement test for ${node.label}\n`;
    result += `${indent}  // Type: ${node.type}\n`;
    result += `${indent}  // ID: ${bpmnId}\n`;
    result += `${indent}  // BPMN File: ${node.bpmnFile}\n`;
    result += `${indent}  // Scenario Path: ${scenarioPath}\n`;
    result += `${indent}  // @initiative:${initiative.toLowerCase().replace(/\s+/g, '-')}\n`;
    result += `${indent}  // @bpmn:${bpmnId}\n`;
    
    // Add type-specific scaffolding
    if (node.type === 'userTask') {
      result += `${indent}  // Example: Test form display and submission\n`;
      result += `${indent}  // await page.goto('/path-to-task');\n`;
      result += `${indent}  // await expect(page.locator('[data-testid="${bpmnId}-form"]')).toBeVisible();\n`;
    } else if (node.type === 'serviceTask') {
      result += `${indent}  // Example: Mock service call and verify\n`;
      result += `${indent}  // await page.route('**/api/service', route => route.fulfill({ ... }));\n`;
    } else if (node.type === 'businessRuleTask') {
      result += `${indent}  // Example: Test business rule evaluation\n`;
      result += `${indent}  // Provide input data and verify decision output\n`;
    }
    
    result += `${indent}  expect(true).toBe(true); // Replace with actual assertions\n`;
    result += `${indent}});\n`;
  }

  return result;
}

/**
 * Generate documentation from ProcessTree
 * Traverses the tree and generates documentation sections
 */
export function generateDocumentationFromTree(
  root: ProcessTreeNode,
  options: {
    includeOrderIndex?: boolean;
    includeScenarioPath?: boolean;
  } = {}
): string {
  const { includeOrderIndex = true, includeScenarioPath = false } = options;
  
  let html = `<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${root.label} - Process Documentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            min-height: 100vh;
        }
        
        h1 {
            color: #0066cc;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        h2 {
            color: #0066cc;
            font-size: 1.8rem;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        h3 {
            color: #333;
            font-size: 1.3rem;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .meta {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 12px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .badge-process {
            background: #3B82F6;
            color: white;
        }
        
        .badge-callActivity {
            background: #8B5CF6;
            color: white;
        }
        
        .badge-userTask {
            background: #10B981;
            color: white;
        }
        
        .badge-serviceTask {
            background: #F97316;
            color: white;
        }
        
        .badge-businessRuleTask {
            background: #F59E0B;
            color: white;
        }
        
        .diagnostics {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .diagnostics.error {
            background: #f8d7da;
            border-left-color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>${root.label}</h1>
            <p class="subtitle">Process Documentation</p>
            <div class="meta">
                <div class="meta-item">
                    <span>Type:</span>
                    <span class="badge badge-${root.type}">${root.type}</span>
                </div>
                <div class="meta-item">
                    <span>BPMN File:</span>
                    <code>${root.bpmnFile}</code>
                </div>
                ${root.bpmnElementId ? `<div class="meta-item">
                    <span>Element ID:</span>
                    <code>${root.bpmnElementId}</code>
                </div>` : ''}
                ${includeOrderIndex && typeof root.orderIndex === 'number' ? `<div class="meta-item">
                    <span>Order Index:</span>
                    <code>#${root.orderIndex}</code>
                </div>` : ''}
            </div>
        </header>
        
        <section>
            ${generateNodeDocumentation(root, includeOrderIndex, includeScenarioPath)}
        </section>
    </div>
</body>
</html>`;

  return html;
}

/**
 * Recursively generate documentation sections from ProcessTreeNode
 */
function generateNodeDocumentation(
  node: ProcessTreeNode,
  includeOrderIndex: boolean,
  includeScenarioPath: boolean,
  depth: number = 0
): string {
  let html = '';

  // Skip root process node itself, only document its children
  if (depth > 0) {
    const headingLevel = depth === 1 ? 'h2' : depth === 2 ? 'h3' : 'h4';
    const orderPrefix = includeOrderIndex && typeof node.orderIndex === 'number' 
      ? `${node.orderIndex}. ` 
      : '';
    
    html += `<${headingLevel}>${orderPrefix}${node.label}</${headingLevel}>\n`;
    html += `<div class="meta">\n`;
    html += `  <span class="badge badge-${node.type}">${node.type}</span>\n`;
    html += `  <span>File: <code>${node.bpmnFile}</code></span>\n`;
    if (node.bpmnElementId) {
      html += `  <span>Element: <code>${node.bpmnElementId}</code></span>\n`;
    }
    if (includeOrderIndex && typeof node.orderIndex === 'number') {
      html += `  <span>Order: <code>#${node.orderIndex}</code></span>\n`;
    }
    if (includeScenarioPath && node.scenarioPath && node.scenarioPath.length > 0) {
      html += `  <span>Scenario: <code>${node.scenarioPath.join(' ‚Üí ')}</code></span>\n`;
    }
    html += `</div>\n`;

    // Show diagnostics if present
    if (node.diagnostics && node.diagnostics.length > 0) {
      html += `<div class="diagnostics ${node.diagnostics.some(d => d.severity === 'error') ? 'error' : ''}">\n`;
      html += `  <strong>Diagnostics:</strong>\n`;
      html += `  <ul>\n`;
      node.diagnostics.forEach(diag => {
        html += `    <li>[${diag.severity}] ${diag.code}: ${diag.message}</li>\n`;
      });
      html += `  </ul>\n`;
      html += `</div>\n`;
    }

    // Show subprocess link info for callActivities
    if (node.type === 'callActivity' && node.subprocessLink) {
      html += `<div class="meta">\n`;
      html += `  <span>Subprocess: <code>${node.subprocessFile || 'Not matched'}</code></span>\n`;
      html += `  <span>Match Status: <code>${node.subprocessLink.matchStatus}</code></span>\n`;
      html += `</div>\n`;
    }
  }

  // Recursively process children
  if (node.children && Array.isArray(node.children)) {
    node.children.forEach(child => {
      html += generateNodeDocumentation(child, includeOrderIndex, includeScenarioPath, depth + 1);
    });
  }

  return html;
}
