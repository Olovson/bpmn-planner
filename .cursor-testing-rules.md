# Permanent Testing Rules - Global Policy

## ⚠️ CRITICAL: This is a PERMANENT rule for ALL code, ALL projects, FOREVER

## Rule 1: NEVER Duplicate Production Logic in Tests

**Why:** Duplicated logic means tests can pass while production fails. This creates false confidence and makes debugging impossible.

**What to do:**
- ALWAYS import and use the actual production code
- If production code doesn't export what you need, export it from production first, then import it in tests
- If you find yourself copying code from production into tests, STOP IMMEDIATELY

**Example - WRONG:**
```typescript
// ❌ BAD: Duplicated logic
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// Test duplicates the logic
it('calculates total', () => {
  const items = [{ price: 10 }, { price: 20 }];
  const result = items.reduce((sum, item) => sum + item.price, 0); // DUPLICATED!
  expect(result).toBe(30);
});
```

**Example - CORRECT:**
```typescript
// ✅ GOOD: Uses production code
import { calculateTotal } from '@/lib/calculator';

it('calculates total', () => {
  const items = [{ price: 10 }, { price: 20 }];
  expect(calculateTotal(items)).toBe(30); // Uses production code
});
```

## Rule 2: NEVER Create Fallback Solutions in Tests

**Why:** Fallback solutions hide bugs and make debugging impossible. If production fails, tests should fail too.

**What to do:**
- Only use fallbacks for test isolation (e.g., `tmpdir()` for file operations)
- Never create fallback implementations of production logic
- If production code needs a fallback, it should be in production code, not tests

**Example - WRONG:**
```typescript
// ❌ BAD: Fallback in test
it('processes data', () => {
  let result;
  try {
    result = processData(input); // Production code
  } catch {
    result = { default: 'fallback' }; // FALLBACK IN TEST - BAD!
  }
  expect(result).toBeDefined();
});
```

**Example - CORRECT:**
```typescript
// ✅ GOOD: Test fails if production fails
import { processData } from '@/lib/processor';

it('processes data', () => {
  const result = processData(input); // If this fails, test fails - GOOD!
  expect(result).toBeDefined();
});
```

## Rule 3: Tests Must Use Same Code Paths as Production

**Why:** This is the ONLY way to ensure tests catch bugs in production code.

**What to do:**
- Import production functions directly
- Use the same parameters and return types
- Test the actual behavior, not a mock of it

## Rule 4: Mock Only External Dependencies

**What to mock:**
- External APIs
- Databases (for isolation)
- File system (use `tmpdir()` for isolation)
- Network requests

**What NOT to mock:**
- Internal production code you're testing
- Business logic
- Utility functions from your own codebase

## Enforcement

This rule is enforced in:
1. `.cursorrules` - Project-specific rules
2. This file - Permanent documentation
3. Code review - Always check for duplicated logic
4. Test failures - If tests pass but production fails, check for duplication

## Remember

**Tests should validate production code, not a copy of it.**

If you're duplicating logic or creating fallbacks, you're not testing production code - you're testing a different implementation that happens to be similar.

